<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Jean's Blog]]></title>
  <link href="http://ziwu1216.github.com/atom.xml" rel="self"/>
  <link href="http://ziwu1216.github.com/"/>
  <updated>2013-07-25T10:54:39+08:00</updated>
  <id>http://ziwu1216.github.com/</id>
  <author>
    <name><![CDATA[Jean]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[『转载』垃圾回收算法]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/07/25/garbage-collection/"/>
    <updated>2013-07-25T10:41:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/07/25/garbage-collection</id>
    <content type="html"><![CDATA[<p>偶然看到的关于垃圾回收算法的综述，很久没有看到可以不用代码说清楚事情的文章了，感觉很深入浅出，适合我这种完全没有基础的人入门。完整转载，没有做任何修改，因为害怕丢失原文的有趣之处。</p>

<!--more-->


<p>转载自：<a href="http://blog.csdn.net/gaooo/article/details/1368934">内存整理的原理是什么？</a></p>

<h2>拓荒时代</h2>

<p>国内的程序员大多是在 Java 语言中第一次感受到垃圾收集技术的巨大魅力的，许多人也因此把 Java 和垃圾收集看成了密不可分的整体。但事实上，垃圾收集技术早在 Java 语言问世前 30 多年就已经发展和成熟起来了， Java 语言所做的不过是把这项神奇的技术带到了广大程序员身边而已。</p>

<p>如果一定要为垃圾收集技术找一个孪生兄弟，那么， Lisp 语言才是当之无愧的人选。 1960 年前后诞生于 MIT 的 Lisp 语言是第一种高度依赖于动态内存分配技术的语言： Lisp 中几乎所有数据都以“表”的形式出现，而“表”所占用的空间则是在堆中动态分配得到的。 Lisp 语言先天就具有的动态内存管理特性要求 Lisp 语言的设计者必须解决堆中每一个内存块的自动释放问题（否则， Lisp 程序员就必然被程序中不计其数的 free 或 delete 语句淹没），这直接导致了垃圾收集技术的诞生和发展——说句题外话，上大学时，一位老师曾告诉我们， Lisp 是对现代软件开发技术贡献最大的语言。我当时对这一说法不以为然：布满了圆括号，看上去像迷宫一样的 Lisp 语言怎么能比 C 语言或 Pascal 语言更伟大呢？不过现在，当我知道垃圾收集技术、数据结构技术、人工智能技术、并行处理技术、虚拟机技术、元数据技术以及程序员们耳熟能详的许多技术都起源于 Lisp 语言时，我特别想向那位老师当面道歉，并收回我当时的幼稚想法。</p>

<p>知道了 Lisp 语言与垃圾收集的密切关系，我们就不难理解，为什么垃圾收集技术的两位先驱者 J. McCarthy 和 M. L. Minsky 同时也是 Lisp 语言发展史上的重要人物了。 J. McCarthy 是 Lisp 之父，他在发明 Lisp 语言的同时也第一次完整地描述了垃圾收集的算法和实现方式； M. L. Minsky 则在发展 Lisp 语言的过程中成为了今天好几种主流垃圾收集算法的奠基人——和当时不少技术大师的经历相似， J. McCarthy 和 M. L. Minsky 在许多不同的技术领域里都取得了令人艳羡的成就。也许，在 1960 年代那个软件开发史上的拓荒时代里，思维敏捷、意志坚定的研究者更容易成为无所不能的西部硬汉吧。</p>

<p>在了解垃圾收集算法的起源之前，有必要先回顾一下内存分配的主要方式。我们知道，大多数主流的语言或运行环境都支持三种最基本的内存分配方式，它们分别是：</p>

<ul>
<li>静态分配（ Static Allocation ）：静态变量和全局变量的分配形式。我们可以把静态分配的内存看成是家里的耐用家具。通常，它们无需释放和回收，因为没人会天天把大衣柜当作垃圾扔到窗外。</li>
<li>自动分配（ Automatic Allocation ）：在栈中为局部变量分配内存的方法。栈中的内存可以随着代码块退出时的出栈操作被自动释放。这类似于到家中串门的访客，天色一晚就要各回各家，除了个别不识时务者以外，我们一般没必要把客人捆在垃圾袋里扫地出门。</li>
<li>动态分配（ Dynamic Allocation ）：在堆中动态分配内存空间以存储数据的方式。堆中的内存块好像我们日常使用的餐巾纸，用过了就得扔到垃圾箱里，否则屋内就会满地狼藉。像我这样的懒人做梦都想有一台家用机器人跟在身边打扫卫生。在软件开发中，如果你懒得释放内存，那么你也需要一台类似的机器人——这其实就是一个由特定算法实现的垃圾收集器。</li>
</ul>


<p>也就是说，下面提到的所有垃圾收集算法都是在程序运行过程中收集并清理废旧“餐巾纸”的算法，它们的操作对象既不是静态变量，也不是局部变量，而是堆中所有已分配内存块。</p>

<h3>引用计数（ Reference Counting ）算法</h3>

<p>1960 年以前，人们为胚胎中的 Lisp 语言设计垃圾收集机制时，第一个想到的算法是引用计数算法。拿餐巾纸的例子来说，这种算法的原理大致可以描述为：</p>

<p>午餐时，为了把脑子里突然跳出来的设计灵感记下来，我从餐巾纸袋中抽出一张餐巾纸，打算在上面画出系统架构的蓝图。按照“餐巾纸使用规约之引用计数版”的要求，画图之前，我必须先在餐巾纸的一角写上计数值 1 ，以表示我在使用这张餐巾纸。这时，如果你也想看看我画的蓝图，那你就要把餐巾纸上的计数值加 1 ，将它改为 2 ，这表明目前有 2 个人在同时使用这张餐巾纸（当然，我是不会允许你用这张餐巾纸来擦鼻涕的）。你看完后，必须把计数值减 1 ，表明你对该餐巾纸的使用已经结束。同样，当我将餐巾纸上的内容全部誊写到笔记本上之后，我也会自觉地把餐巾纸上的计数值减 1 。此时，不出意外的话，这张餐巾纸上的计数值应当是 0 ，它会被垃圾收集器——假设那是一个专门负责打扫卫生的机器人——捡起来扔到垃圾箱里，因为垃圾收集器的惟一使命就是找到所有计数值为 0 的餐巾纸并清理它们。</p>

<p>引用计数算法的优点和缺陷同样明显。这一算法在执行垃圾收集任务时速度较快，但算法对程序中每一次内存分配和指针操作提出了额外的要求（增加或减少内存块的引用计数）。更重要的是，引用计数算法无法正确释放循环引用的内存块，对此， D. Hillis 有一段风趣而精辟的论述：</p>

<p>一天，一个学生走到 Moon 面前说：“我知道如何设计一个更好的垃圾收集器了。我们必须记录指向每个结点的指针数目。” Moon 耐心地给这位学生讲了下面这个故事：“一天，一个学生走到 Moon 面前说：‘我知道如何设计一个更好的垃圾收集器了……’”</p>

<p>D. Hillis 的故事和我们小时候常说的“从前有座山，山上有个庙，庙里有个老和尚”的故事有异曲同工之妙。这说明，单是使用引用计数算法还不足以解决垃圾收集中的所有问题。正因为如此，引用计数算法也常常被研究者们排除在狭义的垃圾收集算法之外。当然，作为一种最简单、最直观的解决方案，引用计数算法本身具有其不可替代的优越性。 1980 年代前后， D. P. Friedman ， D. S. Wise ， H. G. Baker 等人对引用计数算法进行了数次改进，这些改进使得引用计数算法及其变种（如延迟计数算法等）在简单的环境下，或是在一些综合了多种算法的现代垃圾收集系统中仍然可以一展身手。</p>

<h3>标记－清除（ Mark-Sweep ）算法</h3>

<p>第一种实用和完善的垃圾收集算法是 J. McCarthy 等人在 1960 年提出并成功地应用于 Lisp 语言的标记－清除算法。仍以餐巾纸为例，标记－清除算法的执行过程是这样的：</p>

<p>午餐过程中，餐厅里的所有人都根据自己的需要取用餐巾纸。当垃圾收集机器人想收集废旧餐巾纸的时候，它会让所有用餐的人先停下来，然后，依次询问餐厅里的每一个人：“你正在用餐巾纸吗？你用的是哪一张餐巾纸？”机器人根据每个人的回答将人们正在使用的餐巾纸画上记号。询问过程结束后，机器人在餐厅里寻找所有散落在餐桌上且没有记号的餐巾纸（这些显然都是用过的废旧餐巾纸），把它们统统扔到垃圾箱里。</p>

<p>正如其名称所暗示的那样，标记－清除算法的执行过程分为“标记”和“清除”两大阶段。这种分步执行的思路奠定了现代垃圾收集算法的思想基础。与引用计数算法不同的是，标记－清除算法不需要运行环境监测每一次内存分配和指针操作，而只要在“标记”阶段中跟踪每一个指针变量的指向——用类似思路实现的垃圾收集器也常被后人统称为跟踪收集器（ Tracing Collector ）</p>

<p>伴随着 Lisp 语言的成功，标记－清除算法也在大多数早期的 Lisp 运行环境中大放异彩。尽管最初版本的标记－清除算法在今天看来还存在效率不高（标记和清除是两个相当耗时的过程）等诸多缺陷，但在后面的讨论中，我们可以看到，几乎所有现代垃圾收集算法都是标记－清除思想的延续，仅此一点， J. McCarthy 等人在垃圾收集技术方面的贡献就丝毫不亚于他们在 Lisp 语言上的成就了。</p>

<h3>复制（ Copying ）算法</h3>

<p>为了解决标记－清除算法在垃圾收集效率方面的缺陷， M. L. Minsky 于 1963 年发表了著名的论文“一种使用双存储区的 Lisp 语言垃圾收集器（ A LISP Garbage Collector Algorithm Using Serial Secondary Storage ）”。 M. L. Minsky 在该论文中描述的算法被人们称为复制算法，它也被 M. L. Minsky 本人成功地引入到了 Lisp 语言的一个实现版本中。</p>

<p>复制算法别出心裁地将堆空间一分为二，并使用简单的复制操作来完成垃圾收集工作，这个思路相当有趣。借用餐巾纸的比喻，我们可以这样理解 M. L. Minsky 的复制算法：</p>

<p>餐厅被垃圾收集机器人分成南区和北区两个大小完全相同的部分。午餐时，所有人都先在南区用餐（因为空间有限，用餐人数自然也将减少一半），用餐时可以随意使用餐巾纸。当垃圾收集机器人认为有必要回收废旧餐巾纸时，它会要求所有用餐者以最快的速度从南区转移到北区，同时随身携带自己正在使用的餐巾纸。等所有人都转移到北区之后，垃圾收集机器人只要简单地把南区中所有散落的餐巾纸扔进垃圾箱就算完成任务了。下一次垃圾收集的工作过程也大致类似，惟一的不同只是人们的转移方向变成了从北区到南区。如此循环往复，每次垃圾收集都只需简单地转移（也就是复制）一次，垃圾收集速度无与伦比——当然，对于用餐者往返奔波于南北两区之间的辛劳，垃圾收集机器人是决不会流露出丝毫怜悯的。</p>

<p>M. L. Minsky 的发明绝对算得上一种奇思妙想。分区、复制的思路不仅大幅提高了垃圾收集的效率，而且也将原本繁纷复杂的内存分配算法变得前所未有地简明和扼要（既然每次内存回收都是对整个半区的回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存就可以了），这简直是个奇迹！不过，任何奇迹的出现都有一定的代价，在垃圾收集技术中，复制算法提高效率的代价是人为地将可用内存缩小了一半。实话实说，这个代价未免也太高了一些。</p>

<p>无论优缺点如何，复制算法在实践中都获得了可以与标记－清除算法相比拟的成功。除了 M. L. Minsky 本人在 Lisp 语言中的工作以外，从 1960 年代末到 1970 年代初， R. R. Fenichel 和 J. C. Yochelson 等人也相继在 Lisp 语言的不同实现中对复制算法进行了改进， S. Arnborg 更是成功地将复制算法应用到了 Simula 语言中。</p>

<p>至此，垃圾收集技术的三大传统算法——引用计数算法、标记－清除算法和复制算法——都已在 1960 年前后相继问世，三种算法各有所长，也都存在致命的缺陷。从 1960 年代后期开始，研究者的主要精力逐渐转向对这三种传统算法进行改进或整合，以扬长避短，适应程序设计语言和运行环境对垃圾收集的效率和实时性所提出的更高要求。</p>

<h2>走向成熟</h2>

<p>从 1970 年代开始，随着科学研究和应用实践的不断深入，人们逐渐意识到，一个理想的垃圾收集器不应在运行时导致应用程序的暂停，不应额外占用大量的内存空间和 CPU 资源，而三种传统的垃圾收集算法都无法满足这些要求。人们必须提出更新的算法或思路，以解决实践中碰到的诸多难题。当时，研究者的努力目标包括：</p>

<ul>
<li>提高垃圾收集的效率。使用标记－清除算法的垃圾收集器在工作时要消耗相当多的 CPU 资源。早期的 Lisp 运行环境收集内存垃圾的时间竟占到了系统总运行时间的 40% ！——垃圾收集效率的低下直接造就了 Lisp 语言在执行速度方面的坏名声；直到今天，许多人还条件反射似地误以为所有 Lisp 程序都奇慢无比。</li>
<li>减少垃圾收集时的内存占用。这一问题主要出现在复制算法中。尽管复制算法在效率上获得了质的突破，但牺牲一半内存空间的代价仍然是巨大的。在计算机发展的早期，在内存价格以 KB 计算的日子里，浪费客户的一半内存空间简直就是在变相敲诈或拦路打劫。</li>
<li>寻找实时的垃圾收集算法。无论执行效率如何，三种传统的垃圾收集算法在执行垃圾收集任务时都必须打断程序的当前工作。这种因垃圾收集而造成的延时是许多程序，特别是执行关键任务的程序没有办法容忍的。如何对传统算法进行改进，以便实现一种在后台悄悄执行，不影响——或至少看上去不影响——当前进程的实时垃圾收集器，这显然是一件更具挑战性的工作。</li>
</ul>


<p>研究者们探寻未知领域的决心和研究工作的进展速度同样令人惊奇：在 1970 年代到 1980 年代的短短十几年中，一大批在实用系统中表现优异的新算法和新思路脱颖而出。正是因为有了这些日趋成熟的垃圾收集算法，今天的我们才能在 Java 或 .NET 提供的运行环境中随心所欲地分配内存块，而不必担心空间释放时的风险。</p>

<h3>标记－整理（ Mark-Compact ）算法</h3>

<p>标记－整理算法是标记－清除算法和复制算法的有机结合。把标记－清除算法在内存占用上的优点和复制算法在执行效率上的特长综合起来，这是所有人都希望看到的结果。不过，两种垃圾收集算法的整合并不像 1 加 1 等于 2 那样简单，我们必须引入一些全新的思路。 1970 年前后， G. L. Steele ， C. J. Cheney 和 D. S. Wise 等研究者陆续找到了正确的方向，标记－整理算法的轮廓也逐渐清晰了起来：</p>

<p>在我们熟悉的餐厅里，这一次，垃圾收集机器人不再把餐厅分成两个南北区域了。需要执行垃圾收集任务时，机器人先执行标记－清除算法的第一个步骤，为所有使用中的餐巾纸画好标记，然后，机器人命令所有就餐者带上有标记的餐巾纸向餐厅的南面集中，同时把没有标记的废旧餐巾纸扔向餐厅北面。这样一来，机器人只消站在餐厅北面，怀抱垃圾箱，迎接扑面而来的废旧餐巾纸就行了。</p>

<p>实验表明，标记－整理算法的总体执行效率高于标记－清除算法，又不像复制算法那样需要牺牲一半的存储空间，这显然是一种非常理想的结果。在许多现代的垃圾收集器中，人们都使用了标记－整理算法或其改进版本。</p>

<h3>增量收集（ Incremental Collecting ）算法</h3>

<p>对实时垃圾收集算法的研究直接导致了增量收集算法的诞生。</p>

<p>最初，人们关于实时垃圾收集的想法是这样的：为了进行实时的垃圾收集，可以设计一个多进程的运行环境，比如用一个进程执行垃圾收集工作，另一个进程执行程序代码。这样一来，垃圾收集工作看上去就仿佛是在后台悄悄完成的，不会打断程序代码的运行。</p>

<p>在收集餐巾纸的例子中，这一思路可以被理解为：垃圾收集机器人在人们用餐的同时寻找废弃的餐巾纸并将它们扔到垃圾箱里。这个看似简单的思路会在设计和实现时碰上进程间冲突的难题。比如说，如果垃圾收集进程包括标记和清除两个工作阶段，那么，垃圾收集器在第一阶段中辛辛苦苦标记出的结果很可能被另一个进程中的内存操作代码修改得面目全非，以至于第二阶段的工作没有办法开展。</p>

<p>M. L. Minsky 和 D. E. Knuth 对实时垃圾收集过程中的技术难点进行了早期的研究， G. L. Steele 于 1975 年发表了题为“多进程整理的垃圾收集（ Multiprocessing compactifying garbage collection ）”的论文，描述了一种被后人称为“ Minsky-Knuth-Steele 算法”的实时垃圾收集算法。 E. W. Dijkstra ， L. Lamport ， R. R. Fenichel 和 J. C. Yochelson 等人也相继在此领域做出了各自的贡献。 1978 年， H. G. Baker 发表了“串行计算机上的实时表处理技术（ List Processing in Real Time on a Serial Computer ）”一文，系统阐述了多进程环境下用于垃圾收集的增量收集算法。</p>

<p>增量收集算法的基础仍是传统的标记－清除和复制算法。增量收集算法通过对进程间冲突的妥善处理，允许垃圾收集进程以分阶段的方式完成标记、清理或复制工作。详细分析各种增量收集算法的内部机理是一件相当繁琐的事情，在这里，读者们需要了解的仅仅是： H. G. Baker 等人的努力已经将实时垃圾收集的梦想变成了现实，我们再也不用为垃圾收集打断程序的运行而烦恼了。</p>

<h3>分代收集（ Generational Collecting ）算法</h3>

<p>和大多数软件开发技术一样，统计学原理总能在技术发展的过程中起到强力催化剂的作用。 1980 年前后，善于在研究中使用统计分析知识的技术人员发现，大多数内存块的生存周期都比较短，垃圾收集器应当把更多的精力放在检查和清理新分配的内存块上。这个发现对于垃圾收集技术的价值可以用餐巾纸的例子概括如下：</p>

<p>如果垃圾收集机器人足够聪明，事先摸清了餐厅里每个人在用餐时使用餐巾纸的习惯——比如有些人喜欢在用餐前后各用掉一张餐巾纸，有的人喜欢自始至终攥着一张餐巾纸不放，有的人则每打一个喷嚏就用去一张餐巾纸——机器人就可以制定出更完善的餐巾纸回收计划，并总是在人们刚扔掉餐巾纸没多久就把垃圾捡走。这种基于统计学原理的做法当然可以让餐厅的整洁度成倍提高。</p>

<p>D. E. Knuth ， T. Knight ， G. Sussman 和 R. Stallman 等人对内存垃圾的分类处理做了最早的研究。 1983 年， H. Lieberman 和 C. Hewitt 发表了题为“基于对象寿命的一种实时垃圾收集器（ A real-time garbage collector based on the lifetimes of objects ）”的论文。这篇著名的论文标志着分代收集算法的正式诞生。此后，在 H. G. Baker ， R. L. Hudson ， J. E. B. Moss 等人的共同努力下，分代收集算法逐渐成为了垃圾收集领域里的主流技术。</p>

<p>分代收集算法通常将堆中的内存块按寿命分为两类，年老的和年轻的。垃圾收集器使用不同的收集算法或收集策略，分别处理这两类内存块，并特别地把主要工作时间花在处理年轻的内存块上。分代收集算法使垃圾收集器在有限的资源条件下，可以更为有效地工作——这种效率上的提高在今天的 Java 虚拟机中得到了最好的证明。</p>

<h2>应用浪潮</h2>

<p>Lisp 是垃圾收集技术的第一个受益者，但显然不是最后一个。在 Lisp 语言之后，许许多多传统的、现代的、后现代的语言已经把垃圾收集技术拉入了自己的怀抱。随便举几个例子吧：诞生于 1964 年的 Simula 语言， 1969 年的 Smalltalk 语言， 1970 年的 Prolog 语言， 1973 年的 ML 语言， 1975 年的 Scheme 语言， 1983 年的 Modula-3 语言， 1986 年的 Eiffel 语言， 1987 年的 Haskell 语言……它们都先后使用了自动垃圾收集技术。当然，每一种语言使用的垃圾收集算法可能不尽相同，大多数语言和运行环境甚至同时使用了多种垃圾收集算法。但无论怎样，这些实例都说明，垃圾收集技术从诞生的那一天起就不是一种曲高和寡的“学院派”技术。</p>

<p>对于我们熟悉的 C 和 C++ 语言，垃圾收集技术一样可以发挥巨大的功效。正如我们在学校中就已经知道的那样， C 和 C++ 语言本身并没有提供垃圾收集机制，但这并不妨碍我们在程序中使用具有垃圾收集功能的函数库或类库。例如，早在 1988 年， H. J. Boehm 和 A. J. Demers 就成功地实现了一种使用保守垃圾收集算法（ Conservative GC Algorithmic ）的函数库（参见 http://www.hpl.hp.com/personal/Hans_Boehm/gc ）。我们可以在 C 语言或 C++ 语言中使用该函数库完成自动垃圾收集功能，必要时，甚至还可以让传统的 C/C++ 代码与使用自动垃圾收集功能的 C/C++ 代码在一个程序里协同工作。</p>

<p>1995 年诞生的 Java 语言在一夜之间将垃圾收集技术变成了软件开发领域里最为流行的技术之一。从某种角度说，我们很难分清究竟是 Java 从垃圾收集中受益，还是垃圾收集技术本身借 Java 的普及而扬名。值得注意的是，不同版本的 Java 虚拟机使用的垃圾收集机制并不完全相同， Java 虚拟机其实也经过了一个从简单到复杂的发展过程。在 Java 虚拟机的 1.4.1 版中，人们可以体验到的垃圾收集算法就包括分代收集、复制收集、增量收集、标记－整理、并行复制（ Parallel Copying ）、并行清除（ Parallel Scavenging ）、并发（ Concurrent ）收集等许多种， Java 程序运行速度的不断提升在很大程度上应该归功于垃圾收集技术的发展与完善。</p>

<p>尽管历史上已经有许多包含垃圾收集技术的应用平台和操作系统出现，但 Microsoft .NET 却是第一种真正实用化的、包含了垃圾收集机制的通用语言运行环境。事实上， .NET 平台上的所有语言，包括 C# 、 Visual Basic .NET 、 Visual C++ .NET 、 J# 等等，都可以通过几乎完全相同的方式使用 .NET 平台提供的垃圾收集机制。我们似乎可以断言， .NET 是垃圾收集技术在应用领域里的一次重大变革，它使垃圾收集技术从一种单纯的技术变成了应用环境乃至操作系统中的一种内在文化。这种变革对未来软件开发技术的影响力也许要远远超过 .NET 平台本身的商业价值。</p>

<p>大势所趋
今天，致力于垃圾收集技术研究的人们仍在不懈努力，他们的研究方向包括分布式系统的垃圾收集、复杂事务环境下的垃圾收集、数据库等特定系统的垃圾收集等等。</p>

<p>但在程序员中间，仍有不少人对垃圾收集技术不屑一顾，他们宁愿相信自己逐行编写的 free 或 delete 命令，也不愿把垃圾收集的重任交给那些在他们看来既蠢又笨的垃圾收集器。</p>

<p>我个人认为，垃圾收集技术的普及是大势所趋，这就像生活会越来越好一样毋庸置疑。今天的程序员也许会因为垃圾收集器要占用一定的 CPU 资源而对其望而却步，但二十多年前的程序员还曾因为高级语言速度太慢而坚持用机器语言写程序呢！在硬件速度日新月异的今天，我们是要吝惜那一点儿时间损耗而踟躇不前，还是该坚定不移地站在代码和运行环境的净化剂——垃圾收集的一边呢？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Primer 读书笔记 6]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/07/17/c-plus-plus-primer-notes-6/"/>
    <updated>2013-07-17T23:43:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/07/17/c-plus-plus-primer-notes-6</id>
    <content type="html"><![CDATA[<h2>第六章</h2>

<!--more-->


<h3>6.3</h3>

<p>复合语句，通常称为块，是用一对花括号括起来的语句序列，标识了一个作用域。</p>

<h3>6.4</h3>

<p>变量的作用域</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span><span class="c1">//新的作用域，包含在for语句作用域内</span>
</span><span class='line'>  <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//外部不能访问i</span>
</span></code></pre></td></tr></table></div></figure>


<h3>6.6</h3>

<p><code>break</code>语句中，<code>case</code>标号必须是整型常量表达式</p>

<p>程序从匹配的<code>case</code>标号开始执行，并跨越<code>case</code>边界继续执行其他语句直到结束，所以不要忘记<code>break</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">switch</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="sc">&#39;a&#39;</span>:
</span><span class='line'>      <span class="o">++</span><span class="n">aCnt</span><span class="p">;</span>
</span><span class='line'>  <span class="k">case</span> <span class="sc">&#39;e&#39;</span>:
</span><span class='line'>      <span class="o">++</span><span class="n">eCnt</span><span class="p">;</span>
</span><span class='line'>  <span class="k">case</span><span class="err">‘</span><span class="n">i</span><span class="err">’</span>:
</span><span class='line'>      <span class="o">++</span><span class="n">iCnt</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//如果ch是&#39;e&#39;,eCnt和iCnt都会加1</span>
</span><span class='line'>
</span><span class='line'><span class="k">switch</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="sc">&#39;a&#39;</span>:
</span><span class='line'>  <span class="k">case</span> <span class="sc">&#39;e&#39;</span>:
</span><span class='line'>  <span class="o">++</span><span class="n">Cnt</span><span class="p">;</span>
</span><span class='line'>  <span class="k">break</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//对两个case执行同样操作</span>
</span><span class='line'>
</span><span class='line'><span class="k">switch</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nb">true</span>:
</span><span class='line'>      <span class="n">string</span> <span class="n">file_name</span> <span class="o">=</span> <span class="s">&quot;a.txt&quot;</span><span class="p">;</span><span class="c1">//错误！</span>
</span><span class='line'>      <span class="k">break</span><span class="p">;</span>
</span><span class='line'>  <span class="k">case</span> <span class="nb">false</span>:
</span><span class='line'>      <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//只能在最后一个case标号或default标号后面定义变量，此规则是为了避免代码跳过变量的定义和初始化</span>
</span><span class='line'><span class="k">switch</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nb">true</span>:
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="n">string</span> <span class="n">file_name</span> <span class="o">=</span> <span class="s">&quot;a.txt&quot;</span><span class="p">;</span><span class="c1">//在块语句内定义，可以</span>
</span><span class='line'>          <span class="c1">//...</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="k">break</span><span class="p">;</span>
</span><span class='line'>  <span class="k">case</span> <span class="nb">false</span>:
</span><span class='line'>      <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>6.8</h3>

<p><code>for</code>语句</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">initializer</span><span class="p">;</span> <span class="n">condition</span><span class="p">;</span> <span class="n">expression</span><span class="p">)</span>
</span><span class='line'>  <span class="n">statement</span>
</span><span class='line'><span class="c1">//循环开始时执行一次initializer，如果第一次求解condition就得false，则expression和statement都不会执行</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//可以在initializer定义多个对象，但必须具有相同的一般类型</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">ival</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">ia</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ri</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span> <span class="n">ival</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">ival</span><span class="p">,</span> <span class="o">++</span><span class="n">pi</span><span class="p">,</span> <span class="o">++</span><span class="n">ri</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>6.9</h3>

<p><code>do while</code> 保证循环体至少执行1次</p>

<h3>6.11</h3>

<p><code>continue</code>语句导致最近的循环语句的档次迭代提前结束，对于<code>while</code>和<code>do while</code>，继续求解循环条件，对于<code>for</code>，求解<code>expression</code></p>

<h3>6.12</h3>

<p><code>goto</code>语句</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">ix</span> <span class="o">=</span><span class="mi">10</span><span class="p">;</span><span class="c1">//goto语句不能跨越变量的定义语句向前跳转，必须放在块语句内</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nl">end:</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="nl">begin:</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">get_size</span><span class="p">();</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">sz</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">goto</span> <span class="n">begin</span><span class="p">;</span><span class="c1">//向后跳过是合法的，会使系统撤销这个变量，然后再重新创建</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>6.13</h3>

<p><code>try catch</code>语句</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">try</span><span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="n">throw</span> <span class="n">runtime_err</span><span class="p">(</span><span class="s">&quot;Data must be intergers&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span> <span class="n">catch</span> <span class="err">（</span><span class="n">runtime_error</span> <span class="n">err</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">err</span><span class="p">.</span><span class="n">what</span><span class="p">();</span><span class="c1">//每个标准库异常类都有what函数，返回C风格字符串</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>抛出异常时，按执行路径回退，寻找匹配的<code>catch</code>，如果不存在，则转到名为<code>terminate</code>的标准库函数。在程序中出现的异常如果没有<code>try</code>块定义，也将调用<code>terminate</code>。</p>

<p>标准异常类在<code>stdexpect</code>头文件中，见下表<br/>
<img src="http://ziwu1216.github.com/images/c-plus-plus-primer-notes-6-exception.jpg" title="标准异常类" alt="图片加载失败 :("></p>

<p><code>exception</code>, <code>bad_alloc</code>, <code>bad_cast</code>只定义了默认构造函数，无法提供初值。其他异常类使用string参数初始化，这个string被<code>what</code>函数返回</p>

<h3>6.14</h3>

<p><code>assert</code>语句</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="cp">#ifndef NDEBUG</span>
</span><span class='line'>  <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;starting main&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="cp">#endif</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">CC</span> <span class="o">-</span><span class="n">DNDEBUG</span> <span class="n">main</span><span class="p">.</span><span class="n">C</span>
</span><span class='line'><span class="c1">//大多数编译器都提供定义NDEBUG的命令行选项，这样的命令行等效于在main.c开头#define NDEBUG</span>
</span><span class='line'>
</span><span class='line'><span class="n">__FILE__</span>
</span><span class='line'><span class="n">__LINE__</span>
</span><span class='line'><span class="n">__TIME__</span>
</span><span class='line'><span class="n">__DATE__</span>
</span><span class='line'><span class="c1">//预处理器还提供了这些常量，方便调试</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#include &lt;cassert&gt;</span>
</span><span class='line'><span class="n">assert</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span>
</span><span class='line'><span class="c1">//如果expr为false，则输出信息且终止程序。若为非0值，则不做操作</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果NDEBUG定义，则assert语句不运行。</p>

<ul>
<li><a href="http://book.51cto.com/art/201306/400313.htm">具体1</a></li>
<li><a href="http://www.cnblogs.com/valuel/archive/2009/11/15/1603362.html">具体2</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Primer 读书笔记 5]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/07/17/c-plus-plus-primer-notes-5/"/>
    <updated>2013-07-17T23:43:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/07/17/c-plus-plus-primer-notes-5</id>
    <content type="html"><![CDATA[<h2>第五章</h2>

<!--more-->


<h3>5.1</h3>

<p><code>%</code>求余符号，只支持整型操作数，<code>bool</code> <code>char</code> <code>short</code> <code>int</code> <code>long</code></p>

<h3>5.2</h3>

<p>短路求值：<code>expr1 &amp;&amp; expr2</code> 逻辑与，只有expr1为true时，才会计算expr2。逻辑或类似</p>

<h3>5.3</h3>

<p>位操作符将整型操作数视为二进制位的集合，为每一位提供检验和设置的功能，也可用于bitset类型的操作数</p>

<table>
<thead>
<tr>
<th align="center">操作符   </th>
<th align="center">  功能</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">~       </td>
<td align="center">  位求反</td>
</tr>
<tr>
<td align="center">&lt;&lt;      </td>
<td align="center">  左移，填入0</td>
</tr>
<tr>
<td align="center">>>      </td>
<td align="center">  右移，无符号数填入0，有符号数填入符号位副本或者0值</td>
</tr>
<tr>
<td align="center">&amp;       </td>
<td align="center">  位与</td>
</tr>
<tr>
<td align="center">^       </td>
<td align="center">  位异或</td>
</tr>
<tr>
<td align="center">“竖”打不出来 </td>
<td align="center"> 位或</td>
</tr>
</tbody>
</table>


<p>大多数二元操作符都是左结合：<code>( cout&lt;&lt; "hi" ) &lt;&lt; "there";</code></p>

<h3>5.4</h3>

<p>赋值操作符具有右结合性<br/>
复合赋值操作符：<code>+=</code> (减 / 乘 / 除) <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>&amp;=</code> (位异或 / 位或)。<br/>
使用复合赋值操作符时，左操作数只计算了一次</p>

<h3>5.5</h3>

<p>前自增返回修改后的值作为表达式结果，所以返回对象本身，是左值。后自增返回未修改的值，是右值</p>

<h3>5.7</h3>

<p><code>cond ? expr1 : expr2</code>cond总是要计算的，true则计算expr1,false则计算expr2</p>

<h3>5.8</h3>

<p>sizeof返回size_t类型</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">sizeof</span><span class="p">(</span><span class="n">type</span> <span class="n">name</span><span class="p">);</span>
</span><span class='line'><span class="k">sizeof</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span>
</span><span class='line'><span class="k">sizeof</span> <span class="n">expr</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">sizeof</span><span class="err">（</span><span class="kt">char</span><span class="p">)</span> <span class="c1">//保证得1 （推断：单位为byte）</span>
</span><span class='line'><span class="k">sizeof</span><span class="p">(</span><span class="err">引用）</span><span class="c1">//返回存放此引用类型对象所需的内存空间的大小</span>
</span><span class='line'><span class="k">sizeof</span><span class="p">(</span><span class="err">指针）</span><span class="c1">//返回存放指针所需的内存大小</span>
</span><span class='line'><span class="k">sizeof</span><span class="p">(</span><span class="err">数组）</span><span class="c1">//等效于sizeof（元素类型）* 元素个数</span>
</span></code></pre></td></tr></table></div></figure>


<h3>5.9</h3>

<p>逗号操作符的表达式从左向右计算，结果是最右边表达式的值</p>

<h3>5.10</h3>

<p><code>if (ia[index++] &lt; ia[index])</code>此表达式行为未定义，因为&lt;不保证先求解左操作数还是右操作数</p>

<h3>5.11</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">string</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="n">new</span> <span class="n">string</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="sc">&#39;9&#39;</span><span class="p">);</span> <span class="c1">//初始化为999999999</span>
</span><span class='line'><span class="n">string</span> <span class="o">*</span><span class="n">ps2</span> <span class="o">=</span> <span class="n">new</span> <span class="n">string</span><span class="p">();</span>       <span class="c1">//值初始化为空string</span>
</span><span class='line'><span class="kt">int</span> <span class="n">x</span><span class="p">();</span><span class="c1">//声明了函数。值初始化的()必须放在类型名后面，而非变量后</span>
</span></code></pre></td></tr></table></div></figure>


<h3>5.12</h3>

<p><a href="http://mwtx.blog.163.com/blog/static/3893912920117246365145/">整型提升</a><br/>
两个操作数都不是三种浮点类型之一，它们一定是某种整值类型。在确定共同的目标提升类型之前，编译器将在所有小于int的整值类型上施加一个被称为整型提升(integral promotion)的过程。整型提升就是char、short int和位段类型（无论signed或unsigned）以及枚举类型将被提升为int， 前提是int 能够完整地容纳原先的数据，否则将被转换为unsigned int。wchar_t和枚举类型被提升为能够表示其底层类型(underlying type)所有值的最小整数类型。 <br/>
一旦整型提升执行完毕，类型比较就又一次开始。如果一个操作数是unsigned long型，则第二个也被转换成unsigned long型。<br/>
如果该类型所有可能值都包容在int内（取决于机器），则被提升为int。否则被提升为unsigned int。<br/>
如果涉及到int提升为unsigned int且int恰好为负数，则结果是该负数对该类型的取值个数求模后的值.</p>

<p><code>while(cin&gt;&gt;s)</code>将istream类型转换为bool类型，意味着要检验流的状态，如果最后一次尝试成功，则true；否则false</p>

<h4><a href="http://blog.csdn.net/geeeeeeee/article/details/3427920">强制类型转换</a></h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span><span class='line'><span class="n">dynamic_cast</span><span class="o">&lt;&gt;</span><span class="p">()</span>      <span class="c1">//支持运行时识别指针或引用所指向的对象</span>
</span><span class='line'><span class="n">const_cast</span><span class="o">&lt;&gt;</span><span class="p">()</span>        <span class="c1">//转换掉const性质</span>
</span><span class='line'><span class="n">reinterpret_cast</span><span class="o">&lt;&gt;</span><span class="p">()</span>  <span class="c1">//为操作数的位模式提供较低层次的重新解释</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">a</span>
</span><span class='line'><span class="kt">int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span><span class='line'><span class="c1">//旧式强制类型转换</span>
</span><span class='line'><span class="c1">//在合法使用static_cast或const_cast的地方，提供相应功能，如果两者皆不合法，执行reinterpret_cast</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Primer 读书笔记 4]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/07/17/c-plus-plus-primer-notes-4/"/>
    <updated>2013-07-17T23:42:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/07/17/c-plus-plus-primer-notes-4</id>
    <content type="html"><![CDATA[<h2>第四章</h2>

<!--more-->


<h3>4.1</h3>

<p>关于数组定义</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">vals</span><span class="p">[</span><span class="n">size</span><span class="p">];</span><span class="c1">//错，因为size不是const，所以只有运行时才能确定值，不能用于指定数组维数</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">ia</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
</span><span class='line'><span class="c1">//显示初始化的数组不需要指定维数。如果指定维数，大于提供元素个数，其余默认初始化（0或默认构造）。</span>
</span><span class='line'><span class="c1">//若没有显式初始化</span>
</span><span class='line'><span class="c1">//内置类型的数组，在函数体外元素均初始化为0，函数体内无初始化</span>
</span><span class='line'><span class="c1">//类类型的数组，无论在哪里定义，都调用该类的默认构造函数进行初始化。若没有默认构造函数，必须显示初始化</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="n">ca1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;C&#39;</span><span class="p">,</span> <span class="sc">&#39;+&#39;</span><span class="p">,</span> <span class="err">&#39;</span><span class="o">+</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">};</span>
</span><span class='line'><span class="kt">char</span> <span class="n">ca2</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;C++&quot;</span><span class="p">;</span><span class="c1">//同样有结束字符</span>
</span></code></pre></td></tr></table></div></figure>


<p>数组下标的正确类型是<code>size_t</code></p>

<h3>4.2</h3>

<p>取地址符<code>&amp;</code>只能用于左值</p>

<p>建议指针定义时初始化，如果还没有对象，初始化为0</p>

<p>指针和引用的区别：</p>

<ul>
<li>定义引用时必须初始化，以后始终指向同一个特定对象</li>
<li>给引用赋值，修改的是该引用所关联的对象的值，而不是使引用关联另一个对象</li>
</ul>


<p>在表达式中使用数组名时，该名字会自动转换为指向数组第一个元素的指针</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">ia</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">};</span>
</span><span class='line'><span class="kt">int</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">ia</span><span class="p">;</span> <span class="c1">//ip指向ia[0]</span>
</span><span class='line'><span class="kt">int</span> <span class="o">*</span><span class="n">ip2</span> <span class="o">=</span> <span class="n">ia</span> <span class="o">+</span><span class="mi">4</span><span class="p">;</span> <span class="c1">//指向ia[4]</span>
</span><span class='line'><span class="kt">ptrdiff_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">ip2</span> <span class="o">-</span> <span class="n">ip</span><span class="p">;</span><span class="c1">// 4</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ia</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span><span class='line'><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">];</span> <span class="c1">//ia[0]</span>
</span></code></pre></td></tr></table></div></figure>


<p>只要定义的多个变量具有相同的类型，就可以在for循环的初始化语句中同时定义它们</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">pbegin</span> <span class="o">=</span> <span class="n">int_arr</span><span class="p">,</span> <span class="o">*</span><span class="n">pend</span> <span class="o">=</span> <span class="n">int_arr</span> <span class="o">+</span> <span class="n">arr_sz</span><span class="p">;</span> <span class="n">pbegin</span> <span class="o">!=</span> <span class="n">pend</span><span class="p">;</span> <span class="o">++</span><span class="n">pbegin</span><span class="p">)</span>
</span><span class='line'>  <span class="n">dosomething</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>关于const</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">cptr</span><span class="p">;</span><span class="c1">//指向const对象的指针</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
</span><span class='line'><span class="kt">double</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">;</span> <span class="c1">//错误！不能把const对象的地址赋给指向非const对象的指针</span>
</span><span class='line'><span class="c1">//但允许把非const对象的地址赋给指向const对象的指针，常见于函数形参</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="o">*</span><span class="k">const</span> <span class="n">curErr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">errNum</span><span class="p">;</span><span class="c1">//const指针，定义时初始化</span>
</span><span class='line'>
</span><span class='line'><span class="k">typedef</span> <span class="n">string</span> <span class="o">*</span><span class="n">pstring</span><span class="p">;</span>
</span><span class='line'><span class="k">const</span> <span class="n">pstring</span> <span class="n">cstr</span><span class="p">;</span> <span class="c1">//等价于string *const cstr;</span>
</span><span class='line'>
</span><span class='line'><span class="n">string</span> <span class="k">const</span> <span class="n">s1</span><span class="p">;</span> <span class="c1">//等价于const string s1;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>4.3</h3>

<p>字符串字面值是const char类型的数组，是C风格字符串（以null结束的字符数组）的实例。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="s">&quot;C++&quot;</span><span class="p">;</span> <span class="c1">//指向第一个元素的指针</span>
</span><span class='line'>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">cp</span><span class="p">)</span>              <span class="c1">//null字符为false</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">do</span> <span class="n">something</span><span class="p">;</span>
</span><span class='line'>  <span class="n">cp</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>关于char指针的输出</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="s">&quot;C++&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">cp</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>       <span class="c1">//C</span>
</span><span class='line'><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">cp</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>        <span class="c1">//C++</span>
</span><span class='line'><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">cp</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//0x804e739</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="sc">&#39;c&#39;</span><span class="p">;</span>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">;</span>
</span><span class='line'><span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>        <span class="c1">//c</span>
</span><span class='line'><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>         <span class="c1">//c</span>
</span><span class='line'><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">//0xbf7481fb</span>
</span></code></pre></td></tr></table></div></figure>


<p>标准库函数</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;cstring&gt;</span>
</span><span class='line'><span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>   <span class="c1">//不包括null的长度</span>
</span><span class='line'><span class="n">strcmp</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
</span><span class='line'><span class="n">strncpy</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="n">strncat</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="n">largeStr</span><span class="p">[</span><span class="mi">16</span><span class="o">+</span><span class="mi">18</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span>      <span class="c1">//记住预留存放null的空间</span>
</span><span class='line'><span class="n">strncpy</span><span class="p">(</span><span class="n">largeStr</span><span class="p">,</span> <span class="n">cp1</span><span class="p">,</span> <span class="mi">17</span><span class="p">);</span>  <span class="c1">//比使用相应简化版本strcpy(largeStr, cp1)安全</span>
</span><span class='line'><span class="n">strncat</span><span class="p">(</span><span class="n">largeStr</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>   <span class="c1">//包括null的大小</span>
</span><span class='line'><span class="n">strncat</span><span class="p">(</span><span class="n">largeStr</span><span class="p">,</span> <span class="n">cp2</span><span class="p">,</span> <span class="mi">19</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//对应C++标准库类型string，增强安全性，且提高效率</span>
</span><span class='line'><span class="n">string</span> <span class="n">largeStr</span> <span class="o">=</span> <span class="n">cp1</span><span class="p">;</span>
</span><span class='line'><span class="n">largeStr</span> <span class="o">+=</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">largeStr</span> <span class="o">+=</span> <span class="n">cp2</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>动态数组</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="o">*</span><span class="n">pia</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>  <span class="c1">//内置类型无初始化。类类型使用默认构造函数初始化</span>
</span><span class='line'><span class="kt">int</span> <span class="o">*</span><span class="n">pia2</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">//所有元素初始化为0。不能像数组变量一样提供非默认值的初始化</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pci_bad</span> <span class="o">=</span> <span class="n">new</span> <span class="k">const</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span><span class="c1">//错误！const必须初始化</span>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>   <span class="c1">//合法</span>
</span><span class='line'><span class="kt">char</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>             <span class="c1">//错误！</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>可以把C风格字符串用在任何可以使用字符串字面值的地方，例如对string对象进行初始化或赋值</li>
<li>不可直接使用string对象在要求C风格字符串的地方，但可以使用<code>const char *str = st2.c_str();</code></li>
<li>可以使用数组初始化vector。<code>vector&lt;int&gt; ivec(int_arr, int_arr + arr_size);</code></li>
</ul>


<h3>4.4</h3>

<p>严格的说，C++没有多维数组，只是数组的数组</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">ia</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
</span><span class='line'>  <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">},</span>
</span><span class='line'>  <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">};</span>   <span class="c1">//大小为3的数组，其中每个元素是一个大小为4的数组,3行，4列</span>
</span><span class='line'><span class="kt">int</span> <span class="n">ia</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">};</span><span class="c1">//等价</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span><span class="err">（</span><span class="o">*</span><span class="n">ip</span><span class="err">）</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">ia</span><span class="p">;</span><span class="c1">//多维数组名其实是指向第一个内层数组的指针.从内向外理解，指向含有4个元素的数组的指针</span>
</span><span class='line'>
</span><span class='line'><span class="k">typedef</span> <span class="kt">int</span> <span class="n">int_array</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="c1">//更易理解</span>
</span><span class='line'><span class="n">int_array</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">ia</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Primer 读书笔记 3]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/07/17/c-plus-plus-primer-notes-3/"/>
    <updated>2013-07-17T23:42:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/07/17/c-plus-plus-primer-notes-3</id>
    <content type="html"><![CDATA[<p>之前一直在看，但好久没更博客了，所以这次会一次性有很多笔记</p>

<!--more-->


<h2>第三章</h2>

<h3>3.1</h3>

<p>在头文件中，不要放置<code>using</code>声明，否则相当于在每个包含该头文件的程序中都放置了同一<code>using</code>声明，不管程序是否需要。</p>

<h3>3.2 string类型</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;string&gt;</span>
</span><span class='line'><span class="n">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span>
</span></code></pre></td></tr></table></div></figure>


<h4>构造函数</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">string</span> <span class="n">s1</span><span class="p">;</span>
</span><span class='line'><span class="n">string</span> <span class="n">s2</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
</span><span class='line'><span class="n">string</span> <span class="n">s3</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">string</span> <span class="n">s4</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="sc">&#39;c&#39;</span><span class="p">);</span><span class="c1">//n个c</span>
</span></code></pre></td></tr></table></div></figure>


<h4>读写</h4>

<p><code>cin&gt;&gt;s</code>会读取并忽略开头所有空白字符（空格、换行、制表），读取字符直到再次遇到空白字符</p>

<p><code>getline(cin, line)</code>从输入流的下一行读取，并保存读取的内容到string对象中，但不包括换行符，与<code>&gt;&gt;</code>的区别是不忽略开头的换行符，假设输入的第一个是换行符，则<code>line</code>为空string</p>

<h4>string相关操作</h4>

<p><code>string.size()</code>返回<code>string::size_type</code>类型，属于配套类型，可以使string类的使用与机器无关。不要将<code>size()</code>返回值赋给int，因为容易溢出。<br/>
string类的关系比较符区分大小写，通常大写字母小于任意小写字母。<br/>
<code>string s3 = s1 + s2;</code>或<code>s1 += s2;</code>可以连接字符串。当进行string和字符串字面值混合连接时，必须保证至少有一个操作数时string的，否则非法。</p>

<h4>字符的处理</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">isalnum</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="c1">//是否是字母或数字</span>
</span><span class='line'><span class="n">isalpha</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="c1">//是否是字母</span>
</span><span class='line'><span class="n">iscntrl</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="c1">//是否是控制字符</span>
</span><span class='line'><span class="n">isdigit</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="c1">//是否是数字</span>
</span><span class='line'><span class="n">ispunct</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="c1">//是否是标点符号</span>
</span><span class='line'><span class="n">islower</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="c1">//是否是小写字母</span>
</span><span class='line'><span class="n">toupper</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="c1">//如果是小写字母，返回其大写字母形式，否则直接返回c</span>
</span></code></pre></td></tr></table></div></figure>


<p>name.h是C标准库头文件，而相应的cname则是对应得c++版本，cname中定义的名字都在std空间内，而name.h中不是</p>

<h3>3.3 vector类型</h3>

<p>vector之前也有过<a href="http://ziwu1216.github.com/blog/2013/03/14/data-structures-notes-3/">一些笔记</a></p>

<p>vector以及其他标准库容器对象的重要属性就在于可以在运行时高效地添加元素。虽然可以对给定元素个数的vector对象预先分配内存，但更有效的方法是先初始化一个空vector对象，再动态增加元素。</p>

<h3>3.4 迭代器</h3>

<p>除了使用下标<code>vec[n]</code>来访问元素外，还可以用迭代器<code>vector&lt;int&gt;::iterator</code>。所有容器都支持迭代器，但只有少数容器支持下标。<br/>
<code>iter1 - iter2</code>得到的类型是<code>difference_type</code>，可正可负<br/>
<code>vi.begin() + vi.size()/2</code>可以直接指向正中间的元素</p>

<h3>3.5 bitset类型</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;bitset&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">bitset</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span><span class="c1">//尖括号内是bitset的长度，必需参数</span>
</span><span class='line'><span class="n">bitset</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;</span> <span class="n">bitvec1</span><span class="p">(</span><span class="n">Oxffff</span><span class="p">);</span><span class="c1">//不足的位被置为0</span>
</span><span class='line'><span class="c1">//string对象下标最大的字符用来初始化bitset下标为0的位。具体见后图</span>
</span><span class='line'><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&quot;1101&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">bitset</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">bitvec4</span><span class="p">(</span><span class="n">str</span><span class="p">);</span><span class="c1">//第2和第3位置为1，其余为0</span>
</span><span class='line'><span class="n">bitset</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="n">bitvec5</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span><span class="c1">//使用从str[5]开始的4个字符的子串来初始化，子串也是从右向左</span>
</span><span class='line'>
</span><span class='line'><span class="n">b</span><span class="p">.</span><span class="n">any</span><span class="p">()</span><span class="c1">//是否存在1</span>
</span><span class='line'><span class="n">b</span><span class="p">.</span><span class="n">none</span><span class="p">()</span><span class="c1">//是否不存在1</span>
</span><span class='line'><span class="n">b</span><span class="p">.</span><span class="n">count</span><span class="p">()</span><span class="c1">//1的个数</span>
</span><span class='line'><span class="n">b</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
</span><span class='line'><span class="n">b</span><span class="p">.</span><span class="n">test</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span><span class="c1">//pos处是否为1</span>
</span><span class='line'><span class="n">b</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span><span class="c1">//若没有pos参数，所有位都置1</span>
</span><span class='line'><span class="n">b</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
</span><span class='line'><span class="n">b</span><span class="p">.</span><span class="n">flip</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span><span class="c1">//取反</span>
</span><span class='line'><span class="n">b</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">flip</span><span class="p">()</span><span class="c1">//也可以</span>
</span><span class='line'><span class="n">b</span><span class="p">.</span><span class="n">to_ulong</span><span class="p">()</span><span class="c1">//返回unsigned long,bitvec4转化为13</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『转载整理』C++关键字]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/05/25/keywords-in-c-plus-plus/"/>
    <updated>2013-05-25T20:30:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/05/25/keywords-in-c-plus-plus</id>
    <content type="html"><![CDATA[<p>extern,const,static</p>

<!--more-->


<h2>编译单元(模块)</h2>

<p>当在VC这样的开发工具上编写完代码，点击编译按钮准备生成exe文件时，VC其实做了两步工作</p>

<ul>
<li>第一步，将每个.cpp(.c)和相应.h文件编译成obj文件.</li>
<li>第二步，将工程中所有的obj文件进行LINK生成最终的.exe文件.</li>
</ul>


<p>那么错误就有可能在两个地方产生，一个是编译时的错误，这个主要是语法错误，另一个是连接错误，主要是重复定义变量等。</p>

<p>我们所说的编译单元就是指在编译阶段生成的每个obj文件，一个obj文件就是一个编译单元，也就是说一个cpp(.c)和它相应的.h文件共同组成了一个编译单元，一个工程由很多个编译单元组成，每个obj文件里包含了变量存储的相对地址等 。</p>

<h2>extern</h2>

<h3>修饰变量或函数</h3>

<p><a href="http://ziwu1216.github.io/blog/2013/05/24/c-plus-plus-primer-notes-2/">前面文章</a>提过了，通常，在模块的头文件中,对本模块提供给其它模块引用的函数和全局变量以关键字extern声明</p>

<p>被extern修饰的变量（外部变量）是静态分配空间的，即程序开始时分配，结束时释放。</p>

<h3>extern C</h3>

<p><code>void foo( int x, int y );</code>函数被C编译器编译后在符号库中的名字为<code>_foo</code>，而C++编译器则会产生像<code>_foo_int_int</code>之类的名字</p>

<p><code>extern C</code>告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的</p>

<p>目的：实现C++与C及其它语言的混合编程</p>

<ul>
<li>在C++中引用C语言中的函数和变量</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* c语言头文件：cExample.h */</span>
</span><span class='line'><span class="cp">#ifndef C_EXAMPLE_H</span>
</span><span class='line'><span class="cp">#define C_EXAMPLE_H</span>
</span><span class='line'>  <span class="k">extern</span> <span class="kt">int</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/* c语言实现文件：cExample.c */</span>
</span><span class='line'><span class="cp">#include &quot;cExample.h&quot;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// c++实现文件，调用add：cppFile.cpp</span>
</span><span class='line'><span class="k">extern</span> <span class="s">&quot;C&quot;</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="cp">#include &quot;cExample.h&quot;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在C中引用C++语言中的函数和变量</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">//C++头文件 cppExample.h</span>
</span><span class='line'><span class="cp">#ifndef CPP_EXAMPLE_H</span>
</span><span class='line'><span class="cp">#define CPP_EXAMPLE_H</span>
</span><span class='line'>  <span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">int</span> <span class="n">add</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">);</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//C++实现文件 cppExample.cpp</span>
</span><span class='line'><span class="err">＃</span><span class="n">include</span> <span class="s">&quot;cppExample.h&quot;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">add</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/* C实现文件 cFile.c</span>
</span><span class='line'><span class="cm">/* 这样会编译出错：＃include &quot;cExample.h&quot; */</span>
</span><span class='line'><span class="k">extern</span> <span class="kt">int</span> <span class="n">add</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">add</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>常见头文件用法</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#ifdef __cplusplus</span>
</span><span class='line'><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
</span><span class='line'><span class="cp">#endif </span>
</span><span class='line'>  <span class="cm">/*...*/</span>
</span><span class='line'><span class="cp">#ifdef __cplusplus</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<h2>const</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">r</span><span class="o">=</span><span class="mi">100</span><span class="p">;</span><span class="c1">//标准const变量声明加初始化，编译器经过类型检查后直接用100在编译时替换。</span>
</span><span class='line'><span class="c1">//比#define的好处在于有类型检查</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">cp</span><span class="p">;</span> <span class="c1">//到char的const指针</span>
</span><span class='line'><span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">pc1</span><span class="p">;</span> <span class="c1">//到const char的指针</span>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pc2</span><span class="p">;</span> <span class="c1">//到const char的指针（后两个声明是等同的）</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//类的const对象只能访问const成员函数，而非const对象可以访问任意的成员函数，包括const成员函数；</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>static</h2>

<h3>static 局部变量</h3>

<p>生存期为这个源程序, 不过作用域仍是局部，例如函数内部的static变量</p>

<h3>static 全局变量</h3>

<p>全局变量本身就是静态存储方式, 再加上static, 是改变他的作用域, 即只能本当前文件访问</p>

<ul>
<li>extern和static不能同时修饰一个变量</li>
<li>当你在头文件中使用static声明了全局变量后，它也同时被定义了（默认初始化为0）</li>
<li>一般定义static全局变量时，都把它放在原文件中而不是头文件，这样就不会给其他模块造成不必要的信息污染</li>
</ul>


<h3>static 函数</h3>

<p>函数的默认作用域是全局可见的, 即整个源程序, 如果在函数前加上static, 表示将其作用域缩小至本文件.</p>

<h3>static成员</h3>

<p>一个static成员只有唯一的一份副本，而不像常规的非static成员那样在每个对象里各有一份副本。</p>

<h3>static成员函数</h3>

<p>一个需要访问类成员，而不需要针对特定对象去调用的函数，也被称为一个static成员函数,它只能访问类的静态成员。</p>

<p>参考链接：<br/>
<a href="http://hi.baidu.com/zyxins/item/41666937440833493075a1e5">C/C++定义全局变量/常量几种方法的区别</a> <br/>
<a href="http://blog.csdn.net/citysheep/article/details/3923073">C++中extern “C”含义深层探索</a> <br/>
<a href="http://hi.baidu.com/laodun/item/8dcebde3d4710fadcf2d4fc7">关于const,static,extern,volatile的用法</a><br/>
<a href="http://www.cnblogs.com/fxjwind/archive/2011/07/05/2098631.html">C语言易混淆关键词详解-const, static, extern, typedef, 声明</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『转载整理』new和malloc的区别]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/05/25/new-vs-malloc/"/>
    <updated>2013-05-25T17:25:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/05/25/new-vs-malloc</id>
    <content type="html"><![CDATA[<p>new可以认为是malloc加构造函数的执行</p>

<!--more-->


<p>主要区别列表如下：</p>

<table>
<thead>
<tr>
<th>new     </th>
<th>   malloc</th>
</tr>
</thead>
<tbody>
<tr>
<td>建立对象    </td>
<td>   分配内存</td>
</tr>
<tr>
<td>c或c++     </td>
<td>   c</td>
</tr>
<tr>
<td>运算符       </td>
<td>   标准库函数</td>
</tr>
<tr>
<td>保留字,不需要头文件支持      </td>
<td>   需要头文件库函数支持</td>
</tr>
<tr>
<td>分配内存+调用类的构造函数   </td>
<td>   只分配内存，不会进行初始化</td>
</tr>
<tr>
<td>自动计算需要分配的空间       </td>
<td>   手动传递字节数</td>
</tr>
<tr>
<td>返回某种数据类型指针      </td>
<td>   返回void指针</td>
</tr>
</tbody>
</table>


<p>参考链接：<br/>
<a href="http://wmnmtm.blog.163.com/blog/static/38245714201203313587/">new与malloc</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Primer 读书笔记 2]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/05/24/c-plus-plus-primer-notes-2/"/>
    <updated>2013-05-24T00:01:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/05/24/c-plus-plus-primer-notes-2</id>
    <content type="html"><![CDATA[<p>有些细节的地方综合网络作了补充</p>

<!--more-->


<h2>第二章</h2>

<h3>2.1</h3>

<p>8bits - byte，4bytes - word</p>

<table>
<thead>
<tr>
<th align="left"> </th>
<th align="center"> 基本内置类型 </th>
<th align="left"> </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">char: </td>
<td align="center"> 1byte   </td>
<td align="left"> 基本字符集<br>char/unsigned char/signed char<br>(使用unsigned或signed来表示char，由编译器决定)</td>
</tr>
<tr>
<td align="left">wchar_t：</td>
<td align="center"> 2 or 4bytes </td>
<td align="left"> 扩展字符集（汉字和日文）</td>
</tr>
<tr>
<td align="left">bool： </td>
<td align="center">   1byte</td>
<td></td>
</tr>
<tr>
<td align="left">   </td>
<td align="center">    </td>
<td align="left">    </td>
</tr>
<tr>
<td align="left">short int (short)： </td>
<td align="center">  2bytes </td>
<td align="left"> 半个word，short/unsigned short</td>
</tr>
<tr>
<td align="left">int: </td>
<td align="center">  4bytes </td>
<td align="left">    一个word，int/unsigned</td>
</tr>
<tr>
<td align="left">long int (long)： </td>
<td align="center">    4bytes </td>
<td align="left">    long/unsigned long</td>
</tr>
<tr>
<td align="left">long long int:  </td>
<td align="center"> 8bytes</td>
<td></td>
</tr>
<tr>
<td align="left">   </td>
<td align="center">    </td>
<td align="left">    </td>
</tr>
<tr>
<td align="left">float： </td>
<td align="center">  4bytes </td>
<td align="left">    ~7 digits</td>
</tr>
<tr>
<td align="left">double： </td>
<td align="center"> 8bytes </td>
<td align="left">    ~15 digits</td>
</tr>
<tr>
<td align="left">long double： </td>
<td align="center">    8bytes </td>
<td align="left">    ~15 digits</td>
</tr>
</tbody>
</table>


<ul>
<li>无符号，最高位和其它位一样，用来表示该数的大小。</li>
<li>有符号，最高位为符号位，1表示负值。</li>
</ul>


<p>正数按原码存放，负数按补码存放。补码就是符号位不变，其余位数取反加1（从最低位开始至找到的第一个1均不变，符号位不变）。-1，原码是10000001，补码应该是11111111</p>

<p>很多时候，把超过取值范围的值赋给unsigned和signed类型，编译器会取模后存储。</p>

<h3>2.2</h3>

<p>字面值常量literal constant。只有内置类型存在字面值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mi">20</span><span class="p">;</span><span class="c1">//十进制 </span>
</span><span class='line'><span class="mo">024</span><span class="p">;</span><span class="c1">//八进制以0开头 </span>
</span><span class='line'><span class="mh">0x14</span><span class="p">;</span><span class="c1">//十六进制以0X或0x开头</span>
</span><span class='line'><span class="mi">128u</span><span class="p">;</span><span class="c1">//unsigned</span>
</span><span class='line'><span class="mi">1024UL</span> <span class="n">or</span> <span class="mi">1024Lu</span><span class="p">;</span><span class="c1">//unsigned long</span>
</span><span class='line'><span class="mi">1L</span><span class="p">;</span><span class="c1">//long</span>
</span><span class='line'><span class="mf">3.14159f</span><span class="p">;</span>
</span><span class='line'><span class="mf">.001f</span><span class="p">;</span>
</span><span class='line'><span class="mf">0.</span><span class="p">;</span>
</span><span class='line'><span class="mf">1E-3</span><span class="n">F</span><span class="p">;</span>
</span><span class='line'><span class="sc">L&#39;a&#39;</span><span class="p">;</span><span class="c1">//wchar_t</span>
</span><span class='line'><span class="err">\</span><span class="mi">0</span><span class="p">;</span><span class="c1">//转义字符\可以将ASCII码转为字面值常量</span>
</span><span class='line'><span class="s">L&quot;a wide string literal&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2.3</h3>

<p>变量初始化：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">ival</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span><span class="c1">//直接初始化</span>
</span><span class='line'><span class="kt">int</span> <span class="n">ival</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span><span class="c1">//复制初始化</span>
</span><span class='line'><span class="kt">double</span> <span class="n">salary</span> <span class="o">=</span> <span class="mf">9.9</span><span class="p">,</span> <span class="n">wage</span><span class="p">(</span><span class="n">salary</span> <span class="o">+</span> <span class="mf">0.01</span><span class="p">);</span><span class="c1">//用前一个变量初始化后一个变量</span>
</span></code></pre></td></tr></table></div></figure>


<p>定义未初始化的变量时：</p>

<ul>
<li>内置类型：函数体外定义的自动初始化为0，函数体内定义的不自动初始化</li>
<li>类类型：必须有默认构造函数才能自动初始化，否则无法定义没有初始值的变量</li>
</ul>


<p>变量的定义用于为变量分配存储空间，可以指定初始值。变量有且仅有一个定义。<br/>
变量的声明用于向程序表明变量的类型和名字，可以声明多次。定义也是声明。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">extern</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span><span class="c1">//声明不定义，在file2，可以使用file1里的变量i(外部存储类型)</span>
</span><span class='line'><span class="kt">int</span> <span class="n">i</span><span class="p">;</span><span class="c1">//定义，在file1</span>
</span><span class='line'>
</span><span class='line'><span class="k">extern</span> <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.1416</span><span class="p">;</span><span class="c1">//定义，因为有初始化，要分配空间</span>
</span></code></pre></td></tr></table></div></figure>


<p>变量的作用域</p>

<ul>
<li>全局作用域：所有函数外部，在程序的任何地方访问</li>
<li>局部作用域：<code>{}</code>括起来的代码范围，例如函数内部</li>
<li>语句作用域：for等语句内，从它定义的位置开始，一直到for所带语句的作用域结束</li>
<li>类作用域：每个类的成员不同于任何其他类(任何其他作用域)的成员</li>
<li>命名空间作用域：namespace</li>
</ul>


<h3>2.4</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">bufSize</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span><span class="c1">//常量在定义时必须初始化</span>
</span><span class='line'>
</span><span class='line'><span class="k">extern</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">bufSize</span> <span class="o">=</span> <span class="n">fcn</span><span class="p">();</span><span class="c1">//定义，在file1</span>
</span><span class='line'><span class="c1">//在全局作用域声明的const变量是定义该对象的文件的局部变量，不能被其他文件访问</span>
</span><span class='line'><span class="c1">//需要加extern，才能被其他文件访问</span>
</span><span class='line'><span class="k">extern</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">bufSize</span><span class="p">;</span><span class="c1">//声明，在file2，可以使用file1里的变量</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2.5</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">ival</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="o">&amp;</span><span class="n">refval</span> <span class="o">=</span> <span class="n">ival</span><span class="p">;</span><span class="c1">//引用只是别名，引用不可能在初始化后绑定到其他对象</span>
</span><span class='line'><span class="kt">int</span> <span class="o">&amp;</span><span class="n">refVal2</span><span class="p">;</span><span class="c1">//错误，引用必须初始化</span>
</span><span class='line'><span class="kt">int</span> <span class="o">&amp;</span><span class="n">refVal3</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span><span class="c1">//错误，引用必需使用同类型的对象初始化</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">ref</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span><span class="c1">//指向const对象的引用</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span><span class="c1">//正确，const引用可以绑定到右值</span>
</span><span class='line'>
</span><span class='line'><span class="kt">double</span> <span class="n">dval</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">ri</span> <span class="o">=</span> <span class="n">dval</span><span class="p">;</span><span class="c1">//正确，const引用可以绑定到不同但相关的类型</span>
</span><span class='line'><span class="c1">//编译器会做如下转换，如果允许非const引用，则对ri的修改只能修改temp，不能修改dval</span>
</span><span class='line'><span class="c1">//int temp = dval;</span>
</span><span class='line'><span class="c1">//const int &amp;ri = temp;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2.6</h3>

<p>typedef可以用来定义类型的同义词</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">typedef</span> <span class="kt">int</span> <span class="n">exam_socre</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2.7</h3>

<p>枚举变量，默认第一个枚举成员赋值为0，后面比前面一个加1</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">enum</span> <span class="n">Points</span><span class="p">{</span><span class="n">point2d</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">point2w</span><span class="p">,</span> <span class="n">point3d</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">point3w</span><span class="p">};</span>
</span><span class='line'><span class="c1">//point2d = 2, point2w = 3比前一个大1</span>
</span><span class='line'><span class="c1">//point3d = 3, 和point2w值重复了，是可以的</span>
</span><span class='line'><span class="c1">//point3w = 4</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2.8</h3>

<p><code>class</code>在第一个访问标号前的任何成员都隐式指定为<code>private</code>，<code>struct</code>则指定为<code>public</code></p>

<h3>2.9</h3>

<p>编译和链接多个源文件</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">CC</span> <span class="o">-</span><span class="n">c</span> <span class="n">main</span><span class="p">.</span><span class="n">cc</span> <span class="n">Sales_item</span><span class="p">.</span><span class="n">cc</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">CC</span> <span class="o">-</span><span class="n">c</span> <span class="n">main</span><span class="p">.</span><span class="n">cc</span>
</span><span class='line'><span class="n">CC</span> <span class="o">-</span><span class="n">c</span> <span class="n">Sales_item</span><span class="p">.</span><span class="n">cc</span>
</span><span class='line'><span class="n">CC</span> <span class="n">main</span><span class="p">.</span><span class="n">o</span> <span class="n">Sales_item</span><span class="p">.</span><span class="n">o</span>
</span></code></pre></td></tr></table></div></figure>


<p>头文件中只能有声明，不能有定义。例外：</p>

<ul>
<li>定义类</li>
<li>定义值在编译时就已知的const对象<br/>
上文“const变量是定义该对象的文件的局部变量”就是为了允许这么做<br/>
实践中，大部分编译器会用相应的常量表达式来替换对这些const变量的使用，所以不会有存储空间存储这类const变量<br/>
不是编译时已知值的const对象不应该放在头文件</li>
<li>定义inline函数</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『转载整理』C/C++中内存机制]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/05/17/memory-in-c-and-c-plus-plus/"/>
    <updated>2013-05-17T00:15:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/05/17/memory-in-c-and-c-plus-plus</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>在多任务操作系统中的每一个进程都运行在一个属于它自己的内存沙盘中。这个沙盘就是虚拟地址空间（virtual address space），在32位模式下它总是一个<code>4GB</code>的内存地址块。这些虚拟地址通过页表（page table）映射到物理内存，页表由操作系统维护并被处理器引用。每一个进程拥有一套属于它自己的页表，只要虚拟地址被使能，那么它就会作用于这台机器上运行的所有软件，包括内核本身，因此一部分虚拟地址必须保留给内核使用</p>

<!--more-->


<p><img src="http://ziwu1216.github.com/images/memory-in-c-and-c-plus-plus-block.png" title="程序内存块" alt="图片加载失败 :("></p>

<p>在Linux中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。内核代码和数据总是可寻址的，随时准备处理中断和系统调用。与此相反，用户模式地址空间的映射随进程切换的发生而不断变化</p>

<p><img src="http://ziwu1216.github.com/images/memory-in-c-and-c-plus-plus-switch.png" title="程序切换" alt="图片加载失败 :("></p>

<p>下面是一个Linux进程的标准的内存段布局</p>

<p><img src="http://ziwu1216.github.com/images/memory-in-c-and-c-plus-plus-layout.png" title="内存布局" alt="图片加载失败 :("></p>

<ul>
<li>进程地址空间中最顶部的段是栈，大多数编程语言将之用于存储局部变量和函数参数。进程中的每一个线程都有属于自己的栈。</li>
<li>在栈的下方是内存映射段。此处，内核将文件的内容直接映射到内存。任何应用程序都可以通过Linux的mmap()或Windows的CreateFileMapping() / MapViewOfFile()请求这种映射。内存映射是一种方便高效的文件I/O方式，所以它被用于加载动态库。</li>
<li>堆用于运行时内存分配。但不同点是，堆用于存储那些生存期与函数调用无关的数据。在C语言中，堆分配的接口是malloc()系列函数，而在具有垃圾收集功能的语言（如C#）中，此接口是new关键字。</li>
<li>BSS（未初始化数据区）保存的是未被初始化的静态变量内容</li>
<li>数据段保存在源代码中已经初始化了的静态变量内容</li>
<li>代码段是只读的，保存了你全部的代码外加零零碎碎的东西，比如字符串字面值。</li>
</ul>


<p>下图展示了这些段以及我们例子中的变量
<img src="http://ziwu1216.github.com/images/memory-in-c-and-c-plus-plus-example.png" title="例子展示" alt="图片加载失败 :("></p>

<h2>C语言中的内存机制</h2>

<ul>
<li><p>栈(Stack)<br/>
位于函数内的局部变量（包括函数实参），由编译器负责分配释放，函数结束，栈变量失效。</p></li>
<li><p>堆(Heap）<br/>
由程序员用malloc/calloc/realloc分配，free释放。如果程序员忘记free了，则会造成内存泄露，程序结束时该片内存会由OS回收。</p></li>
<li><p>全局区/静态区(Global Static Area)<br/>
全局变量和静态变量存放区，程序一经编译好，该区域便存在。程序结束时释放。<br/>
在C语言中，初始化的全局变量和静态变量和未初始化的放在相邻的两个区域。</p></li>
<li><p>C风格字符串常量存储区<br/>
专门存放字符串常量的地方，程序结束时释放。（字符串常量一般放在 .text段 或单独的 .rodata段）【？？？似乎跟C++的常量存储区类似。const常量是否也放在这里？】</p></li>
<li><p>程序代码区</p></li>
</ul>


<h2>C++中的内存机制</h2>

<p>与C相同部分不再描述</p>

<ul>
<li><p>栈(Stack)</p></li>
<li><p>堆（Heap)<br/>
由new申请的内存，由delete或delete[]负责释放。</p></li>
<li><p>自由存储区(Free Storage)<br/>
malloc/calloc/realloc分配的内存。对象的生存周期可以比内存被分配的时间短，即可以用void*访问这块内存，而没有具体对象。自由存储区和堆的本质区别有争议，具体可见<a href="http://hi.baidu.com/yangdgjy/item/23a3c28daa7f495c840fabb2">这里</a></p></li>
<li><p>全局区/静态区(Global Static Area)<br/>
在C++中，由于全局变量和静态变量编译器会给这些变量自动初始化赋值，所以没有区分了初始化变量和未初始化变量了</p></li>
<li><p>常量存储区<br/>
存储字符串常量和其他在编译时已知的数据。整个程序运行期间可见。只读。</p></li>
<li><p>程序代码区</p></li>
</ul>


<hr />

<p>参考链接:</p>

<p><a href="http://blog.csdn.net/drshenlei/article/details/4339110">剖析程序的内存布局</a><br/>
<a href="http://www.cnblogs.com/ComputerG/archive/2012/02/01/2334898.html">c/c++内存机制（一）（原）</a><br/>
<a href="http://www.gotw.ca/gotw/009.htm">Memory Management - Part I</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『整理翻译』Chromium多进程架构]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/05/16/chromium-multi-process-architecture/"/>
    <updated>2013-05-16T23:58:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/05/16/chromium-multi-process-architecture</id>
    <content type="html"><![CDATA[<p>不是完全翻译，只是在理解的基础上摘录了大致意思，而且对我自己感兴趣的部分可能详细一点，对其他简略一点</p>

<p>原网址<a href="http://www.chromium.org/developers/design-documents/multi-process-architecture">http://www.chromium.org/developers/design-documents/multi-process-architecture</a></p>

<!--more-->


<p>本文档描述了Chromium的上层架构。</p>

<h2>问题</h2>

<p>浏览器的渲染引擎容易崩溃，安全性也不完美，且单个网页的问题可能影响整个浏览器关闭。</p>

<h2>架构概览</h2>

<p>主要进程称作&#8221;browser process&#8221;或&#8221;browser&#8221;，运行UI和管理tab和plugin的进程。针对标签的进程称作&#8221;render processes&#8221;或者&#8221;renderers&#8221;.
<img src="http://ziwu1216.github.com/images/chromium-multi-process-architecture.png" title="Chromium架构" alt="图片加载失败 :("></p>

<h3>管理render processes</h3>

<p>每个render process有一个全局的<code>RenderProcess</code>对象。browser为每个render process维持一个相应的<code>RenderProcessHost</code>。browser和renderers通过IPC通信。</p>

<h3>管理视图（view）</h3>

<p>每个render process有一个或多个<code>RenderView</code>对象，被<code>RenderProcess</code>管理，对应于内容标签。相应的<code>RenderProcessHost</code>维持一个<code>RenderViewHost</code>。每个view有一个view ID，在一个renderer中是唯一的，但在一个browser中不唯一。</p>

<h2>组件和接口</h2>

<p>在render process:</p>

<ul>
<li><code>RenderProcess</code>处理IPC，每个render process有且只有一个<code>RenderProcess</code></li>
<li><code>RenderView</code>与对应的<code>RenderViewHost</code>通信（通过<code>RenderProcess</code>），以及与我们的WebKit嵌入层通信。这个对象代表网页内容</li>
</ul>


<p>在browser process:</p>

<ul>
<li><code>Browser</code>对象代表顶层浏览器窗口</li>
<li><code>RenderProcessHost</code>代表单个browser<->renderer IPC连接的browser端。每个render process有一个<code>RenderProcessHost</code>在browser中。</li>
<li><code>RenderViewHost</code>封装和<code>RenderView</code>的通信，<code>RenderWidgetHost</code>为browser里的<code>RenderWidget</code>处理输入和绘制</li>
</ul>


<h2>共享render process</h2>

<p>某些情况下会共享</p>

<h2>检测崩溃或行为错误的renderers</h2>

<p>每个IPC连接会监测process句柄。如果句柄接收到信号，说明render process崩溃。</p>

<h2>沙箱</h2>

<p>限制renderer对文件系统、网络、用户显示相关对象的访问</p>

<h2>归还内存</h2>

<p>当系统需要内存时，后台的标签的render process内存优先被释放，通过<code>working set</code>的大小</p>

<h2>插件</h2>

<p>NPAPI插件工作在单独进程</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编程之美 读书笔记 1]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/05/16/beauty-of-programming-1/"/>
    <updated>2013-05-16T23:29:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/05/16/beauty-of-programming-1</id>
    <content type="html"><![CDATA[<p>书籍信息：编程之美——微软技术面试心得；《编程之美》小组著；电子工业出版社</p>

<p>从第二章开始看起的，毕竟是件很功利的事情。</p>

<!--more-->


<h3>2.1</h3>

<p>用右移达到除2的效果，效率很高，可以多想想是否可以利用</p>

<p>求1的个数：var = var &amp; (var - 1)</p>

<p>用查表法，以空间换时间</p>

<p>我写的代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">findOne</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">var</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">var</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">var</span> <span class="o">=</span> <span class="n">var</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">var</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>      <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码修改-注意注释</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">BYTE</span><span class="p">;</span><span class="c1">//常用的宏定义，unsigned int范围不进行检查的话不符合题意</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">findOne</span><span class="p">(</span><span class="n">BYTE</span> <span class="n">var</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="p">{</span><span class="c1">//var!=0冗余</span>
</span><span class='line'>      <span class="n">var</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">var</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span><span class="c1">//复合赋值更高效简洁</span>
</span><span class='line'>      <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="n">a</span><span class="p">;</span><span class="c1">//直接输入给BYTE会得到ASCII码值</span>
</span><span class='line'>  <span class="n">BYTE</span> <span class="n">b</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="o">&gt;</span><span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">//0x前缀表示16进制数，x不区分大小写。0前缀表示8进制数。没有提供直接写2进制数的方法.</span>
</span><span class='line'>    <span class="c1">//8进制和16进制只能表达无符号的正整数</span>
</span><span class='line'>          <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;error&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>          <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">BYTE</span><span class="p">)</span><span class="n">a</span><span class="p">;</span><span class="c1">//【？？？】是否有更恰当的方法，将输入以数字的值读入BYTE？</span>
</span><span class='line'>      <span class="n">c</span> <span class="o">=</span> <span class="n">findOne</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span><span class='line'>      <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2.2</h3>

<p>在比较运算符两边（如&lt;），有符号数和无符号数要匹配</p>

<p>不小于N的数中出现能被5整除的个数：Z=[N/5]+[N/25]+[N/125]+&#8230;每5个一数，有一个数中含有因子5。而每25个一数，有一个数中含有因子25，即2个5，因为之前每5个一数时已经算过一次，所以再加一次</p>

<p>二进制最低位1的位置决定于含有因子2的个数</p>

<p>【？？？】问题2的解法二想不到</p>

<h3>2.3</h3>

<p>把问题转化为同等性质的更小规模的问题。如果某元素个数超过整个数组的一半，那么删除一对不同的元素后，此元素依然超过一半。</p>

<p>【？？？】如何传递数组和指针作为实参，引用传递，const传递等</p>

<h3>2.4</h3>

<p>找规律的题目，我所不擅长的。这里是分别考虑个位、十位、百位&#8230;</p>

<p>我写的代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">calc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">less</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">less</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">-</span> <span class="n">temp</span> <span class="o">/</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>      <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">/</span><span class="mi">10</span><span class="p">;</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="n">less</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>          <span class="n">sum</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
</span><span class='line'>      <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">less</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>          <span class="n">sum</span> <span class="o">+=</span> <span class="n">temp</span> <span class="o">*</span> <span class="n">factor</span> <span class="o">+</span> <span class="n">num</span> <span class="o">-</span> <span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">factor</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="k">else</span>
</span><span class='line'>          <span class="n">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">temp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
</span><span class='line'>      <span class="n">factor</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码修改</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">calc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">lowerNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">currNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">higherNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">//改用这些变量后程序可读性增强了很多</span>
</span><span class='line'>  <span class="c1">//写程序时还是要抓住解决方案的本质，用简明的方法表达出来</span>
</span><span class='line'>  <span class="c1">//如果写的时候觉得很难表达清楚，一定是还没有理清思路，不要急着开始写程序</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">factor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">lowerNum</span> <span class="o">=</span> <span class="n">num</span> <span class="o">-</span> <span class="n">num</span> <span class="o">/</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
</span><span class='line'>      <span class="n">currNum</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">factor</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>      <span class="n">higherNum</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">factor</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="n">currNum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>          <span class="n">sum</span> <span class="o">+=</span> <span class="n">higherNum</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
</span><span class='line'>      <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">currNum</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>          <span class="n">sum</span> <span class="o">+=</span> <span class="n">higherNum</span> <span class="o">*</span> <span class="n">factor</span> <span class="o">+</span> <span class="n">lowerNum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="k">else</span>
</span><span class='line'>          <span class="n">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">higherNum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
</span><span class='line'>      <span class="n">factor</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>【？？？问题2实在是太绕了，没看明白】</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[笔试面试总结]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/05/08/interview-summary/"/>
    <updated>2013-05-08T21:20:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/05/08/interview-summary</id>
    <content type="html"><![CDATA[<p>最近开始参加笔试面试了，主要还是软件技术类的。这是一篇不断更新中的记录总纲，其实主要还是给自己看的&#8230;如果遇到要回来学习的题目什么的我会再加日志。</p>

<p>有总结才有提高。</p>

<!--more-->


<h2>企业开放日，工程师们对各个职业求职的描述(M-shz)</h2>

<h3>测试</h3>

<ul>
<li>思维比掌握了几种编程语言更重要，重点是怎么解决问题</li>
<li>网上面试100题之类的题目可以用来训练思维</li>
<li>操作系统的知识是必要的</li>
<li>软件工程的实际项目</li>
</ul>


<h3>项目经理</h3>

<ul>
<li>毕业直接做这个，比较难，因为level很低而要求control高level的人</li>
<li>从developer转过来的人也不多，因为容易注重细节没有全局观</li>
<li>需要大的视角，以及跟不同的人打交道</li>
<li>面试：产品设计、计划制定、现有产品增加功能</li>
</ul>


<h3>技术支持</h3>

<ul>
<li>电话 + 远程协助</li>
<li>好的技术功底 + 对产品的了解</li>
<li>要求英语好</li>
<li>外向一点</li>
<li>面试：英语、技术基础、逻辑、产品</li>
</ul>


<h2>笔试面试的经过和总结</h2>

<h3>软件测试实习（M-shz）</h3>

<ul>
<li>自我介绍<br/>
中途会打断，所以准备的时候要把重点放在前面说，被打断了也不可惜。不用准备很长。</li>
<li>做过的项目<br/>
对他接触过的地方比较关注，或者要求描述大概。<br/>
可以事先准备下对每个项目的总体介绍，简短说明这个项目是什么。以免到时候说得没有条理。</li>
<li>白板编程<br/>
我修改次数太多了。最好先想好再下笔，尽量考虑全各种情况。<br/>
int->正 负 零，比如传长度，不要理所当然是个非零的数，要处理负数。<br/>
也许下次可以考虑先写测试用例再写程序，这样考虑的情况会多一些。 <br/>
最好在下笔前问清题意，对一些特殊情况怎么处理。</li>
<li>一些面试题、算法题和《编程之美》之类的还是要看的，有些巧妙的解法自己很难想到。</li>
<li>学习一下测试用例应该怎么写。</li>
<li>好多C和C++里的函数不记得了，要复习一下。</li>
<li>有些题目用“双指针”的模式可以很好解决，可以训练一下这方面的思维。</li>
</ul>


<h4>主要题目</h4>

<ul>
<li>string转int的函数实现</li>
<li>寻找单链表的倒数第k个元素</li>
<li>一个数组，其中元素为struct{a,b}，其中a是排序的，如果出现连续相同a，只保留最后一个元素。如果出现连续相同b，也只保留最后一个元素。大意是这样。&#8211;双指针</li>
</ul>


<h3>软件开发实习（N-zj）</h3>

<ul>
<li>presentation</li>
<li>做过的项目<br/>
要准备下自己在这个项目中最大成就，克服的难点和学到的知识</li>
<li>对公司的认识</li>
<li>实习时间<br/>
提前准备下怎么说</li>
<li>有什么问题要提问<br/>
要准备些题目，不然冷场</li>
<li>白板编程<br/>
有意识的选择数据类型，例如longlong等平时不常用的类型很多时候需要用来表示可能很大的数据</li>
<li>上机编程<br/>
我编程太慢了，来不及，要多练习，尽量能一次成型，不要太多次调试。<br/>
上机编程以能运行和可读性为首要要求，不要太追求算法高效。</li>
</ul>


<h4>主要题目</h4>

<ul>
<li>memcpy和strcpy实现</li>
<li>malloc和new的区别</li>
<li>各种关键字修饰的变量存储在堆？栈？其他？数据类型字节数</li>
<li>扑克牌的表示和洗牌函数</li>
<li>三角形向下相邻路径最大和</li>
<li>文件读写的程序</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[英文版Win7中文软件显示乱码的解决]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/04/11/solve-win7-chinese-gibberish/"/>
    <updated>2013-04-11T11:51:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/04/11/solve-win7-chinese-gibberish</id>
    <content type="html"><![CDATA[<p>新电脑装了英文版win7，但是安装国内一些中文软件时，名称和内容都会显示乱码。网上搜到解决方法如下：</p>

<!--more-->


<ul>
<li>打开控制面板 Control Panel</li>
<li>点击Clock, Language, and Region</li>
<li>点击Region and Language</li>
<li>点击Administrative选项卡</li>
<li>点击Change system locale按钮</li>
<li>将Current system locale改为：Chinese(Simplified, PRC)</li>
<li>重启计算机</li>
<li>新安装的软件不会出现乱码（实践中我以前安装的软件仍然会显示乱码，建议卸载重装）</li>
</ul>


<p>参考<a href="http://zhidao.baidu.com/question/219346693.html">http://zhidao.baidu.com/question/219346693.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chrome修改书签时崩溃问题的解决]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/04/11/solve-chrome-crashing/"/>
    <updated>2013-04-11T11:45:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/04/11/solve-chrome-crashing</id>
    <content type="html"><![CDATA[<p>很长一段时间内，我在Chrome中添加书签时总是很容易导致整个浏览器崩溃，但是最近发现另一台新装的电脑却没有这个问题。
在网上搜索后，找到了问题所在和解决方案。</p>

<!--more-->


<h2>具体问题</h2>

<p>点击Chrome地址栏的星形按钮添加书签没问题，但是如果此时想修改书签名称就会崩溃。<br/>
在书签栏上右键->修改，然后修改名称，也会崩溃。<br/>
唯一的方法是打开书签管理器，在其中修改。</p>

<h2>解决</h2>

<p>有道词典的“屏幕取词”功能和Chrome有冲突，关闭就好了。网上有说关闭“划词翻译”的，但我试了一下应该不是它的问题。</p>

<p>我平时本来就比较习惯用“划词翻译”，所以关闭“屏幕取词”影响不大。如果有这个习惯的话，Chrome扩展程序中有一个<code>Youdao Dictionary (by Gecko)</code>，支持双击查词和ctrl+鼠标查词，大概可以作为替代。不过我没有具体使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构与算法分析 读书笔记 4]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/03/18/data-structures-notes-4/"/>
    <updated>2013-03-18T23:53:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/03/18/data-structures-notes-4</id>
    <content type="html"><![CDATA[<p>第三章剩下的部分</p>

<!--more-->


<h2>第三章 表、栈和队列</h2>

<h3>3.4 向量的实现</h3>

<p>vector是基本类类型，这意味着不同于基本数组，vector可以复制并且其占用的内存可以自动回收（通过析构函数）</p>

<p>【？？？】程序第37行，为什么<code>reserve()</code>函数中判断的是<code>newCapacity &lt; theSize</code>而不是<code>newCapacity &lt; theCapacity</code>？</p>

<h3>3.5 表的实现</h3>

<p>在表的前端和末尾添加额外结点作为标志，称为哨兵结点。头部结点称为表头结点，末端的结点称为尾结点。使用好处是可以去掉很多特例，简化程序代码。</p>

<p>List中的代码摘抄</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">class</span> <span class="n">List</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="nl">private:</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">Node</span><span class="p">{...};</span>
</span><span class='line'><span class="nl">public:</span>
</span><span class='line'>    <span class="n">class</span> <span class="n">const_iterator</span><span class="p">{...};</span>
</span><span class='line'>    <span class="n">class</span> <span class="n">iterator</span><span class="o">:</span> <span class="n">public</span> <span class="n">const_iterator</span><span class="p">{...};</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="nl">private:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">theSize</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Node</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Node</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>定义前缀和后缀<code>operator++</code>的区别方法：给前缀指定空参数表，给后缀指定一个匿名的int参数。实现指出在许多可以选择使用前缀或后缀的情况下，使用前缀形式要快于使用后缀形式</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">const_iterator</span> <span class="n">operator</span><span class="o">++</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">const_iterator</span> <span class="n">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">const_iterator</span> <span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
</span><span class='line'>    <span class="o">++</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">old</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3.6 栈ADT</h3>

<p>栈的操作基本只有<code>push(),pop(),top()</code>，只有栈顶元素是可访问的。</p>

<p>栈是一个表，用数组和单向链表都可以实现，所以list和vector都支持栈，且操作为常量时间操作。</p>

<h4>栈的应用</h4>

<p>后缀或逆波兰记法：将<code>4.99*1.06 + 5.99 +6.99*1.06</code>（称为中缀式）记为<code>4.99 1.06 * 5.99 + 6.99 1.06 * +</code>。   当一个表达式以后缀记法给出时，没有必要知道任何优先规则。</p>

<p>可以用栈实现中缀式到后缀式的转换，主要原则是入栈操作符，读取新操作符时，从栈顶弹出直到遇到优先级更低的元素为止【需复习】</p>

<p>尾递归：在最后一行的递归调用，是极差的使用递归的例子。<br/>
通过将代码放到一个while循环中并用每个函数的一个参数代替递归调用，可以机械地消除尾递归。【？？？】不明白尾递归和其他递归的本质区别<br/>
递归总能够被彻底除去（编译器的工作），但提速的同时降低了程序的清晰性。</p>

<h3>3.7 队列ADT</h3>

<p>队列也是表。基本操作<code>enqueue(),dequeue()</code></p>

<p>循环数组：处理front或back到达数组尾端，而数组前面有很多空位的情况。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构与算法分析 读书笔记 3]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/03/14/data-structures-notes-3/"/>
    <updated>2013-03-14T23:58:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/03/14/data-structures-notes-3</id>
    <content type="html"><![CDATA[<p>3.1到3.3节。重点记录的是vector和list的操作函数，因为以前用的比较少</p>

<!--more-->


<h2>第三章 表、栈和队列</h2>

<h3>3.1 抽象数据类型ADT</h3>

<p>抽象数据类型（ADT）是带有一组操作的一些对象的集合。在ADT的定义中根本没有提到这组操作是如何实现的</p>

<h3>3.2 表ADT</h3>

<ul>
<li>简单数组实现：适合在末尾插入元素，之后只有数组访问<br/>
数组是静态分配的，但vector类允许在需要的时候将数组的大小增加一倍</li>
<li>链表实现：适合插入和删除在整个表中都发生<br/>
典型的链表保持至表的两端的链接，为了第一项的添加删除和末尾的新项添加为常量时间【应该是由于在两端操作数据最为常见】<br/>
双向链表，可以方便删除最后一项(方便找到倒数第二项)</li>
</ul>


<h3>3.3 STL中的向量和表</h3>

<p>标准模板库STL实现了公共数据结构，例如表ADT。这些数据结构称为集合（collection）或容器（container）</p>

<ul>
<li>vector给出了表ADT的可增长的数组实现。<br/>
优点：常量时间内可索引【findKth】，缺点：插入或删除代价昂贵（除非发生在末尾），查找效率低【find】</li>
<li>list提供表ADT的双向链表实现。<br/>
优点：插入和删除代价小，缺点：不容易索引，查找效率低</li>
</ul>


<p>常用方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">clear</span><span class="p">();</span><span class="c1">//删除容器内的所有元素</span>
</span><span class='line'><span class="n">bool</span> <span class="n">empty</span><span class="p">();</span>
</span><span class='line'><span class="c1">//以下四个都为常量时间</span>
</span><span class='line'><span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">Object</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span><span class="c1">//在表的末尾添加x</span>
</span><span class='line'><span class="kt">void</span> <span class="n">pop_back</span><span class="p">();</span><span class="c1">//删除表的末尾对象</span>
</span><span class='line'><span class="k">const</span> <span class="n">Object</span> <span class="o">&amp;</span> <span class="n">back</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'><span class="k">const</span> <span class="n">Object</span> <span class="o">&amp;</span> <span class="n">front</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//仅针对list</span>
</span><span class='line'><span class="kt">void</span> <span class="n">push_front</span><span class="p">(</span><span class="k">const</span> <span class="n">Object</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="n">pop_front</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//仅针对vector</span>
</span><span class='line'><span class="n">Object</span> <span class="o">&amp;</span> <span class="n">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">idx</span><span class="p">);</span><span class="c1">//不包含边界检测</span>
</span><span class='line'><span class="n">Object</span> <span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">);</span><span class="c1">//包含边界检测</span>
</span><span class='line'><span class="kt">int</span> <span class="n">capacity</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span><span class="c1">//返回vector的内部容量</span>
</span><span class='line'><span class="kt">void</span> <span class="n">reserve</span><span class="p">(</span><span class="kt">int</span> <span class="n">new</span> <span class="n">Capacity</span><span class="p">);</span><span class="c1">//设定vector的新容量</span>
</span></code></pre></td></tr></table></div></figure>


<h4>迭代器iterator</h4>

<p>通过内置类型iterator来标记位置，例如<code>list&lt;string&gt;::iterator</code>和<code>vector&lt;int&gt;::iterator</code></p>

<p>相关方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">iterator</span> <span class="n">begin</span><span class="p">();</span><span class="c1">//返回指向容器第一项的适当迭代器</span>
</span><span class='line'><span class="n">iterator</span> <span class="n">end</span><span class="p">();</span><span class="c1">//指向容器的终止标志，容器中最后一项的后面的位置，边界之外</span>
</span><span class='line'><span class="n">itr</span><span class="o">++</span><span class="p">;</span> <span class="o">++</span><span class="n">itr</span><span class="p">;</span>
</span><span class='line'><span class="o">*</span><span class="n">itr</span><span class="p">;</span><span class="c1">//返回itr指定位置的对象的引用</span>
</span><span class='line'><span class="n">itr1</span> <span class="o">==</span> <span class="n">itr2</span><span class="p">;</span> <span class="n">itr1</span> <span class="o">!=</span> <span class="n">itr2</span><span class="p">;</span><span class="c1">//是否指向同一个位置</span>
</span><span class='line'><span class="n">iterator</span> <span class="n">insert</span><span class="p">(</span><span class="n">iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">Object</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span><span class="c1">//返回插入项位置。对list常量时间，对vector不是</span>
</span><span class='line'><span class="n">iterator</span> <span class="n">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">pos</span><span class="p">);</span><span class="c1">//返回pos下一个元素的位置，操作完成后pos失效</span>
</span><span class='line'><span class="n">iterator</span> <span class="n">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">start</span><span class="p">,</span> <span class="n">iterator</span> <span class="n">end</span><span class="p">);</span><span class="c1">//删除的元素直到但不包括end</span>
</span></code></pre></td></tr></table></div></figure>


<p>【注意错误】我写的对表使用erase的代码</p>

<figure class='code'><figcaption><span>WRONG!!!</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">//1.erase后itr失效，不能继续使用了</span>
</span><span class='line'><span class="c1">//2.使用itr+2操作会超过lst.end()，越界</span>
</span><span class='line'><span class="c1">//...是否还有其他错误？</span>
</span><span class='line'>
</span><span class='line'><span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">Container</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">removeEveryOtherItem</span><span class="p">(</span><span class="n">Container</span> <span class="o">&amp;</span> <span class="n">lst</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span><span class="n">Container</span><span class="o">::</span><span class="n">iterator</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">lst</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">itr</span> <span class="o">!=</span> <span class="n">lst</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">itr</span><span class="o">=</span><span class="n">itr</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'>        <span class="n">lst</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">itr</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>STL也包含const_iterator，*const_iterator会返回常量引用，不能成为左值</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span>
</span><span class='line'><span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span>
</span></code></pre></td></tr></table></div></figure>


<p>两个版本的begin可以在同一个类里，因为方法的定常性被认为是标号的一部分
如果对非常量容器调用begin，返回iterator的版本被调用。如果对常量容器调用，返回const_iterator</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『转载整理』javascript constructor 详解]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/03/11/javascript-constructor-explanation/"/>
    <updated>2013-03-11T10:43:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/03/11/javascript-constructor-explanation</id>
    <content type="html"><![CDATA[<h2>constructor简介</h2>

<ul>
<li>constructor 属性是每个具有原型的对象的原型成员。</li>
<li>这包括除 Global 和 Math 对象之外的所有内部 JavaScript 对象。</li>
</ul>


<!--more-->


<p>用法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// A constructor function.</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">MyObj</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">String</span><span class="p">(</span><span class="s2">&quot;Hi&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">==</span> <span class="nb">String</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="s2">&quot;Object is a String.&quot;</span><span class="p">);</span>
</span><span class='line'><span class="nb">document</span><span class="p">.</span><span class="nx">write</span> <span class="p">(</span><span class="s2">&quot;&lt;br /&gt;&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyObj</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">==</span> <span class="nx">MyObj</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="s2">&quot;Object constructor is MyObj.&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Output:</span>
</span><span class='line'><span class="c1">// Object is a String.</span>
</span><span class='line'><span class="c1">// Object constructor is MyObj.</span>
</span></code></pre></td></tr></table></div></figure>


<h2>constructor和prototype</h2>

<ul>
<li><code>Foo.prototype.constructor</code>是系统(浏览器)创建的，默认指向Foo。</li>
<li>对象b的constructor属性是通过找到<code>b.__proto__.constructor</code>(即<code>Foo.prototype.constructor</code>)访问的，存在于原型链中，而非对象本身属性</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// 构造函数</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">Foo</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//Foo.prototype存储了新创建对象的原型的引用，我们可以使用它来定义共享的属性或方法 </span>
</span><span class='line'><span class="nx">Foo</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'><span class="nx">Foo</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">calculate</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">z</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">z</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span><span class='line'>  <span class="c1">// Foo.prototype 会自动创建一个特别的属性constructor指向构造函数Foo</span>
</span><span class='line'>  <span class="c1">// 对象b和c可以通过代理找到此构造函数</span>
</span><span class='line'>  <span class="nx">b</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nx">Foo</span><span class="p">,</span> <span class="c1">// true</span>
</span><span class='line'>  <span class="nx">c</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nx">Foo</span><span class="p">,</span> <span class="c1">// true</span>
</span><span class='line'>  <span class="nx">Foo</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nx">Foo</span> <span class="c1">// true</span>
</span><span class='line'><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上对象的关系如下图所示
<img src="http://ziwu1216.github.com/images/javascript-constructor-explanation-relation.jpg" title="关系示意图" alt="图片加载失败:("></p>

<h2>constructor易变</h2>

<p>constructor易变，是因为函数的prototype属性容易被更改。例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">F</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'><span class="nx">_name</span><span class="o">:</span> <span class="s1">&#39;Eric&#39;</span><span class="p">,</span>
</span><span class='line'><span class="nx">getName</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'><span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_name</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">F</span><span class="p">();</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nx">F</span><span class="p">);</span> <span class="c1">// output false</span>
</span><span class='line'>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span><span class="p">);</span><span class="c1">//output true </span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">);</span><span class="c1">// also output true  </span>
</span></code></pre></td></tr></table></div></figure>


<p>F的原型被开发者重写了，这种方式将原有的prototype对象用一个对象的字面量{}来代替。而新建的对象{}只是Object的一个实例，系统（浏览器）在解析的时候并不会在{}上自动添加一个constructor属性，因为这是function创建时的专属操作，仅当你声明函数的时候解析器才会做此动作。<br/>
因为{}是创建对象的一种简写，所以{}相当于是new Object()。因为{}是Object的实例，而Object.prototype上有一个指向Object本身的constructor属性。所以可以看出f.constructor其实就是Object.prototype的constructor，</p>

<p>一个解决办法就是手动恢复他的constructor：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">F</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'><span class="nx">constructor</span><span class="o">:</span> <span class="nx">F</span><span class="p">,</span> <span class="cm">/* reset constructor */</span>
</span><span class='line'><span class="nx">_name</span><span class="o">:</span> <span class="s1">&#39;Eric&#39;</span><span class="p">,</span>
</span><span class='line'><span class="nx">getName</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'><span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_name</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">F</span><span class="p">();</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nx">F</span><span class="p">);</span> <span class="c1">// output true this time ^^ </span>
</span></code></pre></td></tr></table></div></figure>


<hr />

<p>参考链接：<br/>
<a href="http://msdn.microsoft.com/zh-cn/library/c1hcx253.aspx">constructor 属性 (JavaScript)</a><br/>
<a href="http://blog.csdn.net/wanghui499917270/article/details/7171542">V8引擎实现标准ECMA-262（三）</a><br/>
<a href="http://www.douban.com/group/topic/23280359/">揭开constructor属性的神秘面纱</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构与算法分析 读书笔记 2]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/03/10/data-structures-notes-2/"/>
    <updated>2013-03-10T22:39:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/03/10/data-structures-notes-2</id>
    <content type="html"><![CDATA[<p>半个多月前就记了，一直都没整理……第二章</p>

<!--more-->


<h2>第二章 算法分析</h2>

<p>算法是为求解一个问题需要遵循的、被清楚地指定的简单指令的集合。</p>

<h3>2.1 数学基础</h3>

<p><img src="http://ziwu1216.github.com/images/data-structures-notes-2-def.PNG" title="定义" alt="图片加载失败 :(">
这些定义是相对增长率的比较。</p>

<ul>
<li>大O，f是T的上界</li>
<li>omega，g是T的下界</li>
<li>theta，表示严格的增长率相等。<br/>
【？？？】【为什么定义四是对所有常数？】</li>
</ul>


<p>重要法则：<img src="http://ziwu1216.github.com/images/data-structures-notes-2-rule.PNG" title="法则" alt="图片加载失败 :("><br/>
典型增长率：<img src="http://ziwu1216.github.com/images/data-structures-notes-2-rate.PNG" title="典型增长率" alt="图片加载失败 :("></p>

<p>不要将常数或低阶项放进大O</p>

<p>可以通过计算lim（N→+∞）f(N)/g(N)来比较函数的相对增长率（洛必达法则，分子分母求导）</p>

<h3>2.3 要分析的问题</h3>

<p>分析程序的运行时间，一般需要最坏情况而非平均情况，一是因为对所有输入提供界限，二是因为平均计算起来困难。</p>

<p>高效算法中，数据读入常常成为瓶颈。</p>

<h3>2.4 运行时间计算</h3>

<p>一般法则</p>

<ul>
<li>法则1： for循环，时间至多是该循环内语句（包括测试）的运行时间乘以迭代的次数</li>
<li>法则2： 嵌套循环，从里向外分析【也是分析运行时间的基本策略】，一组嵌套循环内部的一条语句总的运行时间，为该语句时间乘以该组所有循环的大小的乘积</li>
<li>法则3： 顺序语句，将各个语句的运行时间求和</li>
<li>法则4： if/else语句，不超过判断语句时间加分支中运行较长的时间之和</li>
</ul>


<p>递归和调用的运行时间分析举例【！！！需复习】<br/>
令T(N)为求解大小为N的问题所花费时间，基准条件得到T(0)，T(1)等，迭代得到关系式如T(N) = 2T(N/2) + O(N),求解。【？？？】【如何求解】</p>

<h4>最大子序列和问题的求解</h4>

<p>多重求和公式计算算法复杂度【！！！需复习】</p>

<p>递归算法，“分治”策略，把整组数据分为左右两个子序列，考虑可能出现在左边，右边，或横跨左右。【！！！需编码】  <br/>
递归函数调用的一般形式是传递输入数组以及左边界和右边界，它们界定了数组要被处理的部分。<br/>
【在递归中，设计传递参数很重要，书中的例子避免了子序列的拷贝，比我开始设计的参数好很多】</p>

<p>联机算法：在任意时刻，算法都能对它已经读入的数据给出问题的正确答案。仅需要常量空间并以线性时间运行的算法几乎是完美的算法。</p>

<h4>O(logN)</h4>

<p>如果一个算法用常数时间将问题的大小削减为其一部分（通常是1/2），那么该算法就是O(logN)的。</p>

<ul>
<li>二分搜索</li>
<li>欧几里得算法</li>
<li>幂运算</li>
</ul>


<h4>检验分析</h4>

<p>方法一是编程并比较N扩大一倍后实际运行时间与分析是否匹配。很多时候很困难。</p>

<p>方法二：验证是否O(f(N))，对N的某个范围计算T(N)/f(n)，T(N)是观察到的运行时间。（收敛于正常数，收敛于0，发散）【？？？】【什么是“用2的倍数隔开”】</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『转载整理』javascript prototype 详解]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/03/10/javascript-prototype-explanation/"/>
    <updated>2013-03-10T00:05:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/03/10/javascript-prototype-explanation</id>
    <content type="html"><![CDATA[<p>没有系统学过JavaScript语言，就要开始对JavaScript引擎做些改动，因此不可避免地撞上了JavaScript的一些独特的特性，例如prototype。</p>

<p>只是最基本的概念理清，不包含复杂的编程模式之类。</p>

<!--more-->


<h2><code>__proto__</code>属性和原型链</h2>

<ul>
<li><code>__proto__</code>是每个JavaScript对象的私有属性，指向对象的原型。原型也是对象。</li>
<li>原型链是指对象上的<code>__proto__</code>链。</li>
<li>属性查找通过原型链进行。</li>
</ul>


<p>这是一个简单的对象定义。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">x</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">y</span><span class="o">:</span> <span class="mi">20</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个结构定义了两个显式属性和一个隐式属性 <code>__proto__</code>，它指向foo的原型
<img src="http://ziwu1216.github.com/images/javascript-prototype-explanation-proto.gif" title="foo对象" alt="图片加载失败 :("></p>

<p>设想两个对象有一些属性不同而其他所有属性都相同的情况，很明显，设计良好的系统应当代码重用，而不是在一个对象中重复定义。
ECMAScript没有类的概念，它是通过原型链来达到同样的效果的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">x</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">calculate</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">z</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">z</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">y</span><span class="o">:</span> <span class="mi">20</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">__proto__</span><span class="o">:</span> <span class="nx">a</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">y</span><span class="o">:</span> <span class="mi">30</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">__proto__</span><span class="o">:</span> <span class="nx">a</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// call the inherited method</span>
</span><span class='line'><span class="nx">b</span><span class="p">.</span><span class="nx">calculate</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span> <span class="c1">// 60</span>
</span><span class='line'><span class="nx">c</span><span class="p">.</span><span class="nx">calculate</span><span class="p">(</span><span class="mi">40</span><span class="p">);</span> <span class="c1">// 80</span>
</span></code></pre></td></tr></table></div></figure>


<p>b和c可以访问a中定义的calculate方法，这就是通过原型链达到的。
规则很简单：如果一个方法或者属性不在一个对象本身里面，那么就尝试在原型链中查找。如果在原型中没有找到，那么就在原型的原型中查找，以此类推查找整个原型链。最先发现的属性或者方法最先使用。如果在整个原型链中都没有找到，将返回undefined值。</p>

<p>注意，那个在继承方法中的this值是原始的对象（b和c），而不是定义这个方法的对象（a），在这个例子中，this.y是b和c中的y，而不是a中的。然而this.x来自于a，但这是通过原型链机制得到的（x本来应该是从b和c中获得，但他们本身没有）</p>

<p>如果一个对象没有显式指定原型，那么默认的<code>__proto__</code>值是Object.prototype。Object.prototype本身也有一个<code>__proto__</code>，它是原型链中的最后一个，其值为null
<img src="http://ziwu1216.github.com/images/javascript-prototype-explanation-prototype-chain.gif" title="原型链" alt="图片加载失败 :("></p>

<h2>prototype和<code>__proto__</code></h2>

<ul>
<li>prototype是JavaScript函数具有的属性</li>
<li>new的时候会把函数的prototype赋给对象的<code>__proto__</code>属性。</li>
</ul>


<p>以下是一个简单的new的过程</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">Person</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="p">};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以把new的过程拆分成三步：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">p</span><span class="o">=</span><span class="p">{};</span>
</span><span class='line'><span class="nx">p</span><span class="p">.</span><span class="nx">__proto__</span><span class="o">=</span><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
</span><span class='line'><span class="nx">Person</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>证明一下第二步。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">Person</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="p">};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">();</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span><span class="c1">//true,ie不支持访问此私有属性</span>
</span></code></pre></td></tr></table></div></figure>


<h2>prototype</h2>

<p>在学习prototype(原型)的时候，我们首先要搞明白这样两个规则：</p>

<ul>
<li>使用原型可以大量减少每个对象对内存的需求量，因为对象可以继承许多属性。</li>
<li>即使属性在对象被创建之后才被添加至原型中，对象也能够继承这些属性。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">//创建一个构造函数 “用户”</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">User</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//实例化一个用户——&gt;老张</span>
</span><span class='line'><span class="kd">var</span> <span class="err">老张</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">User</span><span class="p">(</span><span class="s1">&#39;老张&#39;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//弹窗显示老张的名字</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="err">老张</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//定义原型，注意这里对象“老张”已经被实例化了</span>
</span><span class='line'><span class="nx">User</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">favchannel</span> <span class="o">=</span> <span class="s1">&#39;CCAV&#39;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//弹窗显示老张最喜欢的电视台</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="err">老张</span><span class="p">.</span><span class="nx">favchannel</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>读属性时，顺序是：老张——>User.prototype——>Object.prototype</p>

<p>只有读属性的时候才会使用prototype，写属性的时候是不会用到prototype的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">//老李是一个新的用户</span>
</span><span class='line'><span class="kd">var</span> <span class="err">老李</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">User</span><span class="p">(</span><span class="s1">&#39;老李&#39;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//老李喜欢小电影</span>
</span><span class='line'><span class="err">老李</span><span class="p">.</span><span class="nx">favchannel</span> <span class="o">=</span> <span class="s1">&#39;JAPANTV&#39;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//弹窗显示JAPANTV</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="err">老李</span><span class="p">.</span><span class="nx">favchannel</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//弹窗显示老张还是中意CCAV</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="err">老张</span><span class="p">.</span><span class="nx">favchannel</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>复杂点的原型链</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">Person</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="p">};</span>
</span><span class='line'><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">Say</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;Person say&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">Salary</span> <span class="o">=</span> <span class="mi">50000</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">Programmer</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="p">};</span>
</span><span class='line'><span class="nx">Programmer</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">();</span>
</span><span class='line'><span class="nx">Programmer</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">WriteCode</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;programmer writes code&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="nx">Programmer</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">Salary</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Programmer</span><span class="p">();</span>
</span><span class='line'><span class="nx">p</span><span class="p">.</span><span class="nx">Say</span><span class="p">();</span>
</span><span class='line'><span class="nx">p</span><span class="p">.</span><span class="nx">WriteCode</span><span class="p">();</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Salary</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>详细推导：
<code>var p=new Programmer()</code> => <code>p.__proto__=Programmer.prototype</code>;</p>

<p><code>Programmer.prototype=new Person()</code> => <code>Programmer.prototype.__proto__=Person.prototype</code>;</p>

<p>=> <code>p.__proto__.__proto__=Person.prototype</code></p>

<h2>Next</h2>

<p>我还看到一张更复杂的图，不过要理解下constructor属性，下次继续</p>

<hr />

<p>参考链接：</p>

<p><a href="http://blog.csdn.net/wanghui499917270/article/details/7170207">V8引擎实现标准ECMA-262（二）</a></p>

<p><a href="http://www.cnblogs.com/kym/archive/2010/01/09/1643062.html">Javascript学习笔记7——原型链的原理</a></p>

<p><a href="http://www.xiaoxiaozi.com/2009/06/29/995/">JavaScript prototype原型对象</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构与算法分析 读书笔记 1]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/02/09/data-structures-notes-1/"/>
    <updated>2013-02-09T13:16:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/02/09/data-structures-notes-1</id>
    <content type="html"><![CDATA[<p>看扫描pdf真心累啊，可是家里没有纸质书。。。</p>

<p>书籍信息：数据结构与算法分析 C++描述（第3版）Mark Allen Weiss 著；张怀勇等译；人民邮电出版社</p>

<!--more-->


<h2>第一章 引论</h2>

<h3>1.1 本书讨论的内容</h3>

<p>问题1：选择问题。设有一组N个数，要确定其中第k个最大的数</p>

<p>问题2：输入由一个二维字母数组和一个单词表组成，找出水平、垂直或对角方向放置的单词</p>

<h3>1.2 数学知识复习</h3>

<ul>
<li>几何级数：<img src="http://ziwu1216.github.com/images/data-structures-notes-1-jihe.PNG" title="几何级数" alt="图片加载失败 :("></li>
<li>算术级数：<img src="http://ziwu1216.github.com/images/data-structures-notes-1-suanshu.PNG" title="算术级数" alt="图片加载失败 :("></li>
<li><img src="http://ziwu1216.github.com/images/data-structures-notes-1-gaojie.PNG" title="高阶" alt="图片加载失败 :("></li>
<li>调和数：<img src="http://ziwu1216.github.com/images/data-structures-notes-1-tiaohe.PNG" title="调和数" alt="图片加载失败 :("></li>
</ul>


<p>归纳法：第一步证明基准情形（对于某个或某些值），接着归纳假设（k），然后证明k+1。必须k有限。</p>

<h3>1.3 递归的简单介绍</h3>

<p>递归：需要处理基准情况base case和递归调用。</p>

<p>递归的基本准则</p>

<ul>
<li>基准情形</li>
<li>不断推进：递归调用将一直进行到基准情形出现为止，若永远不能到达基准情形，则出错。</li>
<li>设计法则：假设所有的递归调用都能运行。不追踪实际的递归调用序列。</li>
<li>合成效益法则：在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。</li>
</ul>


<h3>1.4 C++类</h3>

<p>构造函数中，const数据成员和自定义类数据成员，必须在初始化列表里初始化</p>

<p>所有单参数的构造函数都必须是explicit的，以避免后台的类型转换</p>

<p>C++标准定义了两个类vector和string，意在替代内置数组和字符串，增加了=复制、大小确定、==比较等，使用他们几乎总是较好的选择</p>

<h3>1.5 C++细节</h3>

<p>指针最好进行初始化，可以初始化为NULL</p>

<p>按值调用适用于不被函数更改的小对象，按常量引用调用适用于不被函数更改的大对象，引址调用适用于所有可以被函数更改的对象</p>

<p>如果返回值是类类型的，可以使用按常量引用返回以节省复制的开销，但必须保证返回语句中的表达式在函数返回时不被销毁。</p>

<p>三个默认特殊函数：</p>

<ul>
<li>析构函数</li>
<li>复制构造函数：IntCell B = C； IntCell B(C); 按值调用传递时；按值返回时。<br/>
每个数据成员依次复制，若有类对象的数据成员，调用数据成员的复制构造函数</li>
<li>operator=</li>
</ul>


<p>有指针数据成员时，默认特殊函数会造成内存泄露和浅复制</p>

<h3>1.6 模板</h3>

<p>函数模板可以应需要而自动扩展&#8211;>代码膨胀</p>

<p>模板实参可以使用任何类类型，因此尽量使用常量引用</p>

<p>类模板：例如数据成员类型不确定</p>

<p>函数对象：定义一个包含零个数据和一个成员函数的类。使用operator(),调用cmp.operator()(x,y)可以简写为cmp(x,y)，看上去就像函数调用，因此operator()被称为函数调用操作符</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">CaseInsensitiveCompare</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span> <span class="k">return</span> <span class="n">stricmp</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">rhs</span><span class="p">.</span><span class="n">c_str</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Object</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Comparator</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">const</span> <span class="n">Object</span> <span class="o">&amp;</span> <span class="n">findMax</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">arr</span><span class="p">,</span> <span class="n">Comparator</span> <span class="n">isLessThan</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="n">isLessThan</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">maxIndex</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">findMax</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">CaseInsensitiveCompare</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>1.7 使用矩阵</h3>

<p>矩阵matrix类的构造：使用向量的向量，重载operator[]。需要有两个版本的operator[],因为<code>to[i] = from[i]</code>,需要返回一个常量引用给from，返回一个普通引用给to。</p>

<p>【C++这样重载可以正常工作吗？为什么知道调用哪个operator[]？】<br/>
【更新：我在<a href="http://ziwu1216.github.com/blog/2013/03/14/data-structures-notes-3/">第三章</a>里看到了解释】</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">row</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span> <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="n">row</span><span class="p">];</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">row</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span> <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="n">row</span><span class="p">];</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">array</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
</feed>
