<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Jean's Blog]]></title>
  <link href="http://ziwu1216.github.com/atom.xml" rel="self"/>
  <link href="http://ziwu1216.github.com/"/>
  <updated>2013-05-24T14:35:12+08:00</updated>
  <id>http://ziwu1216.github.com/</id>
  <author>
    <name><![CDATA[Jean]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++ Primer 读书笔记 2]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/05/24/c-plus-plus-primer-notes-2/"/>
    <updated>2013-05-24T00:01:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/05/24/c-plus-plus-primer-notes-2</id>
    <content type="html"><![CDATA[<p>有些细节的地方综合网络作了补充</p>

<!--more-->


<h2>第二章</h2>

<h3>2.1</h3>

<p>8bits - byte，4bytes - word</p>

<table>
<thead>
<tr>
<th align="left"> </th>
<th align="center"> 基本内置类型 </th>
<th align="left"> </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">char: </td>
<td align="center"> 1byte   </td>
<td align="left"> 基本字符集<br>char/unsigned char/signed char<br>(使用unsigned或signed来表示char，由编译器决定)</td>
</tr>
<tr>
<td align="left">wchar_t：</td>
<td align="center"> 2 or 4bytes </td>
<td align="left"> 扩展字符集（汉字和日文）</td>
</tr>
<tr>
<td align="left">bool： </td>
<td align="center">   1byte</td>
<td></td>
</tr>
<tr>
<td align="left">   </td>
<td align="center">    </td>
<td align="left">    </td>
</tr>
<tr>
<td align="left">short int (short)： </td>
<td align="center">  2bytes </td>
<td align="left"> 半个word，short/unsigned short</td>
</tr>
<tr>
<td align="left">int: </td>
<td align="center">  4bytes </td>
<td align="left">    一个word，int/unsigned</td>
</tr>
<tr>
<td align="left">long int (long)： </td>
<td align="center">    4bytes </td>
<td align="left">    long/unsigned long</td>
</tr>
<tr>
<td align="left">long long int:  </td>
<td align="center"> 8bytes</td>
<td></td>
</tr>
<tr>
<td align="left">   </td>
<td align="center">    </td>
<td align="left">    </td>
</tr>
<tr>
<td align="left">float： </td>
<td align="center">  4bytes </td>
<td align="left">    ~7 digits</td>
</tr>
<tr>
<td align="left">double： </td>
<td align="center"> 8bytes </td>
<td align="left">    ~15 digits</td>
</tr>
<tr>
<td align="left">long double： </td>
<td align="center">    8bytes </td>
<td align="left">    ~15 digits</td>
</tr>
</tbody>
</table>


<ul>
<li>无符号，最高位和其它位一样，用来表示该数的大小。</li>
<li>有符号，最高位为符号位，1表示负值。</li>
</ul>


<p>正数按原码存放，负数按补码存放。补码就是符号位不变，其余位数取反加1（从最低位开始至找到的第一个1均不变，符号位不变）。-1，原码是10000001，补码应该是11111111</p>

<p>很多时候，把超过取值范围的值赋给unsigned和signed类型，编译器会取模后存储。</p>

<h3>2.2</h3>

<p>字面值常量literal constant。只有内置类型存在字面值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mi">20</span><span class="p">;</span><span class="c1">//十进制 </span>
</span><span class='line'><span class="mo">024</span><span class="p">;</span><span class="c1">//八进制以0开头 </span>
</span><span class='line'><span class="mh">0x14</span><span class="p">;</span><span class="c1">//十六进制以0X或0x开头</span>
</span><span class='line'><span class="mi">128u</span><span class="p">;</span><span class="c1">//unsigned</span>
</span><span class='line'><span class="mi">1024UL</span> <span class="n">or</span> <span class="mi">1024Lu</span><span class="p">;</span><span class="c1">//unsigned long</span>
</span><span class='line'><span class="mi">1L</span><span class="p">;</span><span class="c1">//long</span>
</span><span class='line'><span class="mf">3.14159f</span><span class="p">;</span>
</span><span class='line'><span class="mf">.001f</span><span class="p">;</span>
</span><span class='line'><span class="mf">0.</span><span class="p">;</span>
</span><span class='line'><span class="mf">1E-3</span><span class="n">F</span><span class="p">;</span>
</span><span class='line'><span class="sc">L&#39;a&#39;</span><span class="p">;</span><span class="c1">//wchar_t</span>
</span><span class='line'><span class="err">\</span><span class="mi">0</span><span class="p">;</span><span class="c1">//转义字符\可以将ASCII码转为字面值常量</span>
</span><span class='line'><span class="s">L&quot;a wide string literal&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2.3</h3>

<p>变量初始化：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">ival</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span><span class="c1">//直接初始化</span>
</span><span class='line'><span class="kt">int</span> <span class="n">ival</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span><span class="c1">//复制初始化</span>
</span><span class='line'><span class="kt">double</span> <span class="n">salary</span> <span class="o">=</span> <span class="mf">9.9</span><span class="p">,</span> <span class="n">wage</span><span class="p">(</span><span class="n">salary</span> <span class="o">+</span> <span class="mf">0.01</span><span class="p">);</span><span class="c1">//用前一个变量初始化后一个变量</span>
</span></code></pre></td></tr></table></div></figure>


<p>定义未初始化的变量时：</p>

<ul>
<li>内置类型：函数体外定义的自动初始化为0，函数体内定义的不自动初始化</li>
<li>类类型：必须有默认构造函数才能自动初始化，否则无法定义没有初始值的变量</li>
</ul>


<p>变量的定义用于为变量分配存储空间，可以指定初始值。变量有且仅有一个定义。<br/>
变量的声明用于向程序表明变量的类型和名字，可以声明多次。定义也是声明。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">extern</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span><span class="c1">//声明不定义，在file2，可以使用file1里的变量i(外部存储类型)</span>
</span><span class='line'><span class="kt">int</span> <span class="n">i</span><span class="p">;</span><span class="c1">//定义，在file1</span>
</span><span class='line'>
</span><span class='line'><span class="k">extern</span> <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.1416</span><span class="p">;</span><span class="c1">//定义，因为有初始化，要分配空间</span>
</span></code></pre></td></tr></table></div></figure>


<p>变量的作用域</p>

<ul>
<li>全局作用域：所有函数外部，在程序的任何地方访问</li>
<li>局部作用域：<code>{}</code>括起来的代码范围，例如函数内部</li>
<li>语句作用域：for等语句内，从它定义的位置开始，一直到for所带语句的作用域结束</li>
<li>类作用域：每个类的成员不同于任何其他类(任何其他作用域)的成员</li>
<li>命名空间作用域：namespace</li>
</ul>


<h3>2.4</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">bufSize</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span><span class="c1">//常量在定义时必须初始化</span>
</span><span class='line'>
</span><span class='line'><span class="k">extern</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">bufSize</span> <span class="o">=</span> <span class="n">fcn</span><span class="p">();</span><span class="c1">//定义，在file1</span>
</span><span class='line'><span class="c1">//在全局作用域声明的const变量是定义该对象的文件的局部变量，不能被其他文件访问</span>
</span><span class='line'><span class="c1">//需要加extern，才能被其他文件访问</span>
</span><span class='line'><span class="k">extern</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">bufSize</span><span class="p">;</span><span class="c1">//声明，在file2，可以使用file1里的变量</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2.5</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">ival</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="o">&amp;</span><span class="n">refval</span> <span class="o">=</span> <span class="n">ival</span><span class="p">;</span><span class="c1">//引用只是别名，引用不可能在初始化后绑定到其他对象</span>
</span><span class='line'><span class="kt">int</span> <span class="o">&amp;</span><span class="n">refVal2</span><span class="p">;</span><span class="c1">//错误，引用必须初始化</span>
</span><span class='line'><span class="kt">int</span> <span class="o">&amp;</span><span class="n">refVal3</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span><span class="c1">//错误，引用必需使用同类型的对象初始化</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">ref</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span><span class="c1">//指向const对象的引用</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span><span class="c1">//正确，const引用可以绑定到右值</span>
</span><span class='line'>
</span><span class='line'><span class="kt">double</span> <span class="n">dval</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
</span><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">ri</span> <span class="o">=</span> <span class="n">dval</span><span class="p">;</span><span class="c1">//正确，const引用可以绑定到不同但相关的类型</span>
</span><span class='line'><span class="c1">//编译器会做如下转换，如果允许非const引用，则对ri的修改只能修改temp，不能修改dval</span>
</span><span class='line'><span class="c1">//int temp = dval;</span>
</span><span class='line'><span class="c1">//const int &amp;ri = temp;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2.6</h3>

<p>typedef可以用来定义类型的同义词</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">typedef</span> <span class="kt">int</span> <span class="n">exam_socre</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2.7</h3>

<p>枚举变量，默认第一个枚举成员赋值为0，后面比前面一个加1</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">enum</span> <span class="n">Points</span><span class="p">{</span><span class="n">point2d</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">point2w</span><span class="p">,</span> <span class="n">point3d</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">point3w</span><span class="p">};</span>
</span><span class='line'><span class="c1">//point2d = 2, point2w = 3比前一个大1</span>
</span><span class='line'><span class="c1">//point3d = 3, 和point2w值重复了，是可以的</span>
</span><span class='line'><span class="c1">//point3w = 4</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2.8</h3>

<p><code>class</code>在第一个访问标号前的任何成员都隐式指定为<code>private</code>，<code>struct</code>则指定为<code>public</code></p>

<h3>2.9</h3>

<p>编译和链接多个源文件</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">CC</span> <span class="o">-</span><span class="n">c</span> <span class="n">main</span><span class="p">.</span><span class="n">cc</span> <span class="n">Sales_item</span><span class="p">.</span><span class="n">cc</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">CC</span> <span class="o">-</span><span class="n">c</span> <span class="n">main</span><span class="p">.</span><span class="n">cc</span>
</span><span class='line'><span class="n">CC</span> <span class="o">-</span><span class="n">c</span> <span class="n">Sales_item</span><span class="p">.</span><span class="n">cc</span>
</span><span class='line'><span class="n">CC</span> <span class="n">main</span><span class="p">.</span><span class="n">o</span> <span class="n">Sales_item</span><span class="p">.</span><span class="n">o</span>
</span></code></pre></td></tr></table></div></figure>


<p>头文件中只能有声明，不能有定义。例外：</p>

<ul>
<li>定义类</li>
<li>定义值在编译时就已知的const对象<br/>
上文“const变量是定义该对象的文件的局部变量”就是为了允许这么做<br/>
实践中，大部分编译器会用相应的常量表达式来替换对这些const变量的使用，所以不会有存储空间存储这类const变量<br/>
不是编译时已知值的const对象不应该放在头文件</li>
<li>定义inline函数</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『转载整理』C/C++中内存机制]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/05/17/memory-in-c-and-c-plus-plus/"/>
    <updated>2013-05-17T00:15:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/05/17/memory-in-c-and-c-plus-plus</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>在多任务操作系统中的每一个进程都运行在一个属于它自己的内存沙盘中。这个沙盘就是虚拟地址空间（virtual address space），在32位模式下它总是一个<code>4GB</code>的内存地址块。这些虚拟地址通过页表（page table）映射到物理内存，页表由操作系统维护并被处理器引用。每一个进程拥有一套属于它自己的页表，只要虚拟地址被使能，那么它就会作用于这台机器上运行的所有软件，包括内核本身，因此一部分虚拟地址必须保留给内核使用</p>

<!--more-->


<p><img src="http://ziwu1216.github.com/images/memory-in-c-and-c-plus-plus-block.png" title="程序内存块" alt="图片加载失败 :("></p>

<p>在Linux中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。内核代码和数据总是可寻址的，随时准备处理中断和系统调用。与此相反，用户模式地址空间的映射随进程切换的发生而不断变化</p>

<p><img src="http://ziwu1216.github.com/images/memory-in-c-and-c-plus-plus-switch.png" title="程序切换" alt="图片加载失败 :("></p>

<p>下面是一个Linux进程的标准的内存段布局</p>

<p><img src="http://ziwu1216.github.com/images/memory-in-c-and-c-plus-plus-layout.png" title="内存布局" alt="图片加载失败 :("></p>

<ul>
<li>进程地址空间中最顶部的段是栈，大多数编程语言将之用于存储局部变量和函数参数。进程中的每一个线程都有属于自己的栈。</li>
<li>在栈的下方是内存映射段。此处，内核将文件的内容直接映射到内存。任何应用程序都可以通过Linux的mmap()或Windows的CreateFileMapping() / MapViewOfFile()请求这种映射。内存映射是一种方便高效的文件I/O方式，所以它被用于加载动态库。</li>
<li>堆用于运行时内存分配。但不同点是，堆用于存储那些生存期与函数调用无关的数据。在C语言中，堆分配的接口是malloc()系列函数，而在具有垃圾收集功能的语言（如C#）中，此接口是new关键字。</li>
<li>BSS（未初始化数据区）保存的是未被初始化的静态变量内容</li>
<li>数据段保存在源代码中已经初始化了的静态变量内容</li>
<li>代码段是只读的，保存了你全部的代码外加零零碎碎的东西，比如字符串字面值。</li>
</ul>


<p>下图展示了这些段以及我们例子中的变量
<img src="http://ziwu1216.github.com/images/memory-in-c-and-c-plus-plus-example.png" title="例子展示" alt="图片加载失败 :("></p>

<h2>C语言中的内存机制</h2>

<ul>
<li><p>栈(Stack)<br/>
位于函数内的局部变量（包括函数实参），由编译器负责分配释放，函数结束，栈变量失效。</p></li>
<li><p>堆(Heap）<br/>
由程序员用malloc/calloc/realloc分配，free释放。如果程序员忘记free了，则会造成内存泄露，程序结束时该片内存会由OS回收。</p></li>
<li><p>全局区/静态区(Global Static Area)<br/>
全局变量和静态变量存放区，程序一经编译好，该区域便存在。程序结束时释放。<br/>
在C语言中，初始化的全局变量和静态变量和未初始化的放在相邻的两个区域。</p></li>
<li><p>C风格字符串常量存储区<br/>
专门存放字符串常量的地方，程序结束时释放。（字符串常量一般放在 .text段 或单独的 .rodata段）【？？？似乎跟C++的常量存储区类似。const常量是否也放在这里？】</p></li>
<li><p>程序代码区</p></li>
</ul>


<h2>C++中的内存机制</h2>

<p>与C相同部分不再描述</p>

<ul>
<li><p>栈(Stack)</p></li>
<li><p>堆（Heap)<br/>
由new申请的内存，由delete或delete[]负责释放。</p></li>
<li><p>自由存储区(Free Storage)<br/>
malloc/calloc/realloc分配的内存。对象的生存周期可以比内存被分配的时间短，即可以用void*访问这块内存，而没有具体对象。自由存储区和堆的本质区别有争议，具体可见<a href="http://hi.baidu.com/yangdgjy/item/23a3c28daa7f495c840fabb2">这里</a></p></li>
<li><p>全局区/静态区(Global Static Area)<br/>
在C++中，由于全局变量和静态变量编译器会给这些变量自动初始化赋值，所以没有区分了初始化变量和未初始化变量了</p></li>
<li><p>常量存储区<br/>
存储字符串常量和其他在编译时已知的数据。整个程序运行期间可见。只读。</p></li>
<li><p>程序代码区</p></li>
</ul>


<hr />

<p>参考链接:</p>

<p><a href="http://blog.csdn.net/drshenlei/article/details/4339110">剖析程序的内存布局</a><br/>
<a href="http://www.cnblogs.com/ComputerG/archive/2012/02/01/2334898.html">c/c++内存机制（一）（原）</a><br/>
<a href="http://www.gotw.ca/gotw/009.htm">Memory Management - Part I</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『整理翻译』Chromium多进程架构]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/05/16/chromium-multi-process-architecture/"/>
    <updated>2013-05-16T23:58:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/05/16/chromium-multi-process-architecture</id>
    <content type="html"><![CDATA[<p>不是完全翻译，只是在理解的基础上摘录了大致意思，而且对我自己感兴趣的部分可能详细一点，对其他简略一点</p>

<p>原网址<a href="http://www.chromium.org/developers/design-documents/multi-process-architecture">http://www.chromium.org/developers/design-documents/multi-process-architecture</a></p>

<!--more-->


<p>本文档描述了Chromium的上层架构。</p>

<h2>问题</h2>

<p>浏览器的渲染引擎容易崩溃，安全性也不完美，且单个网页的问题可能影响整个浏览器关闭。</p>

<h2>架构概览</h2>

<p>主要进程称作&#8221;browser process&#8221;或&#8221;browser&#8221;，运行UI和管理tab和plugin的进程。针对标签的进程称作&#8221;render processes&#8221;或者&#8221;renderers&#8221;.
<img src="http://ziwu1216.github.com/images/chromium-multi-process-architecture.png" title="Chromium架构" alt="图片加载失败 :("></p>

<h3>管理render processes</h3>

<p>每个render process有一个全局的<code>RenderProcess</code>对象。browser为每个render process维持一个相应的<code>RenderProcessHost</code>。browser和renderers通过IPC通信。</p>

<h3>管理视图（view）</h3>

<p>每个render process有一个或多个<code>RenderView</code>对象，被<code>RenderProcess</code>管理，对应于内容标签。相应的<code>RenderProcessHost</code>维持一个<code>RenderViewHost</code>。每个view有一个view ID，在一个renderer中是唯一的，但在一个browser中不唯一。</p>

<h2>组件和接口</h2>

<p>在render process:</p>

<ul>
<li><code>RenderProcess</code>处理IPC，每个render process有且只有一个<code>RenderProcess</code></li>
<li><code>RenderView</code>与对应的<code>RenderViewHost</code>通信（通过<code>RenderProcess</code>），以及与我们的WebKit嵌入层通信。这个对象代表网页内容</li>
</ul>


<p>在browser process:</p>

<ul>
<li><code>Browser</code>对象代表顶层浏览器窗口</li>
<li><code>RenderProcessHost</code>代表单个browser<->renderer IPC连接的browser端。每个render process有一个<code>RenderProcessHost</code>在browser中。</li>
<li><code>RenderViewHost</code>封装和<code>RenderView</code>的通信，<code>RenderWidgetHost</code>为browser里的<code>RenderWidget</code>处理输入和绘制</li>
</ul>


<h2>共享render process</h2>

<p>某些情况下会共享</p>

<h2>检测崩溃或行为错误的renderers</h2>

<p>每个IPC连接会监测process句柄。如果句柄接收到信号，说明render process崩溃。</p>

<h2>沙箱</h2>

<p>限制renderer对文件系统、网络、用户显示相关对象的访问</p>

<h2>归还内存</h2>

<p>当系统需要内存时，后台的标签的render process内存优先被释放，通过<code>working set</code>的大小</p>

<h2>插件</h2>

<p>NPAPI插件工作在单独进程</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编程之美 读书笔记 1]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/05/16/beauty-of-programming-1/"/>
    <updated>2013-05-16T23:29:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/05/16/beauty-of-programming-1</id>
    <content type="html"><![CDATA[<p>书籍信息：编程之美——微软技术面试心得；《编程之美》小组著；电子工业出版社</p>

<p>从第二章开始看起的，毕竟是件很功利的事情。</p>

<!--more-->


<h3>2.1</h3>

<p>用右移达到除2的效果，效率很高，可以多想想是否可以利用</p>

<p>求1的个数：var = var &amp; (var - 1)</p>

<p>用查表法，以空间换时间</p>

<p>我写的代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">findOne</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">var</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">var</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">var</span> <span class="o">=</span> <span class="n">var</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">var</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>      <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码修改-注意注释</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">BYTE</span><span class="p">;</span><span class="c1">//常用的宏定义，unsigned int范围不进行检查的话不符合题意</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">findOne</span><span class="p">(</span><span class="n">BYTE</span> <span class="n">var</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="p">{</span><span class="c1">//var!=0冗余</span>
</span><span class='line'>      <span class="n">var</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">var</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span><span class="c1">//复合赋值更高效简洁</span>
</span><span class='line'>      <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="n">a</span><span class="p">;</span><span class="c1">//直接输入给BYTE会得到ASCII码值</span>
</span><span class='line'>  <span class="n">BYTE</span> <span class="n">b</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="o">&gt;</span><span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">//0x前缀表示16进制数，x不区分大小写。0前缀表示8进制数。没有提供直接写2进制数的方法.</span>
</span><span class='line'>    <span class="c1">//8进制和16进制只能表达无符号的正整数</span>
</span><span class='line'>          <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;error&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>          <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">BYTE</span><span class="p">)</span><span class="n">a</span><span class="p">;</span><span class="c1">//【？？？】是否有更恰当的方法，将输入以数字的值读入BYTE？</span>
</span><span class='line'>      <span class="n">c</span> <span class="o">=</span> <span class="n">findOne</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span><span class='line'>      <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2.2</h3>

<p>在比较运算符两边（如&lt;），有符号数和无符号数要匹配</p>

<p>不小于N的数中出现能被5整除的个数：Z=[N/5]+[N/25]+[N/125]+&#8230;每5个一数，有一个数中含有因子5。而每25个一数，有一个数中含有因子25，即2个5，因为之前每5个一数时已经算过一次，所以再加一次</p>

<p>二进制最低位1的位置决定于含有因子2的个数</p>

<p>【？？？】问题2的解法二想不到</p>

<h3>2.3</h3>

<p>把问题转化为同等性质的更小规模的问题。如果某元素个数超过整个数组的一半，那么删除一对不同的元素后，此元素依然超过一半。</p>

<p>【？？？】如何传递数组和指针作为实参，引用传递，const传递等</p>

<h3>2.4</h3>

<p>找规律的题目，我所不擅长的。这里是分别考虑个位、十位、百位&#8230;</p>

<p>我写的代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">calc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">less</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">less</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">-</span> <span class="n">temp</span> <span class="o">/</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>      <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">/</span><span class="mi">10</span><span class="p">;</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="n">less</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>          <span class="n">sum</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
</span><span class='line'>      <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">less</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>          <span class="n">sum</span> <span class="o">+=</span> <span class="n">temp</span> <span class="o">*</span> <span class="n">factor</span> <span class="o">+</span> <span class="n">num</span> <span class="o">-</span> <span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">factor</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="k">else</span>
</span><span class='line'>          <span class="n">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">temp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
</span><span class='line'>      <span class="n">factor</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码修改</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="nf">calc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">lowerNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">currNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">higherNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">//改用这些变量后程序可读性增强了很多</span>
</span><span class='line'>  <span class="c1">//写程序时还是要抓住解决方案的本质，用简明的方法表达出来</span>
</span><span class='line'>  <span class="c1">//如果写的时候觉得很难表达清楚，一定是还没有理清思路，不要急着开始写程序</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">factor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">lowerNum</span> <span class="o">=</span> <span class="n">num</span> <span class="o">-</span> <span class="n">num</span> <span class="o">/</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
</span><span class='line'>      <span class="n">currNum</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">factor</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>      <span class="n">higherNum</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">factor</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="n">currNum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>          <span class="n">sum</span> <span class="o">+=</span> <span class="n">higherNum</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
</span><span class='line'>      <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">currNum</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>          <span class="n">sum</span> <span class="o">+=</span> <span class="n">higherNum</span> <span class="o">*</span> <span class="n">factor</span> <span class="o">+</span> <span class="n">lowerNum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>      <span class="k">else</span>
</span><span class='line'>          <span class="n">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">higherNum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
</span><span class='line'>      <span class="n">factor</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>【？？？问题2实在是太绕了，没看明白】</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[笔试面试总结]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/05/08/interview-summary/"/>
    <updated>2013-05-08T21:20:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/05/08/interview-summary</id>
    <content type="html"><![CDATA[<p>最近开始参加笔试面试了，主要还是软件技术类的。这是一篇不断更新中的记录总纲，其实主要还是给自己看的&#8230;如果遇到要回来学习的题目什么的我会再加日志。</p>

<p>有总结才有提高。</p>

<!--more-->


<h2>企业开放日，工程师们对各个职业求职的描述(M-shz)</h2>

<h3>测试</h3>

<ul>
<li>思维比掌握了几种编程语言更重要，重点是怎么解决问题</li>
<li>网上面试100题之类的题目可以用来训练思维</li>
<li>操作系统的知识是必要的</li>
<li>软件工程的实际项目</li>
</ul>


<h3>项目经理</h3>

<ul>
<li>毕业直接做这个，比较难，因为level很低而要求control高level的人</li>
<li>从developer转过来的人也不多，因为容易注重细节没有全局观</li>
<li>需要大的视角，以及跟不同的人打交道</li>
<li>面试：产品设计、计划制定、现有产品增加功能</li>
</ul>


<h3>技术支持</h3>

<ul>
<li>电话 + 远程协助</li>
<li>好的技术功底 + 对产品的了解</li>
<li>要求英语好</li>
<li>外向一点</li>
<li>面试：英语、技术基础、逻辑、产品</li>
</ul>


<h2>笔试面试的经过和总结</h2>

<h3>软件测试实习（M-shz）</h3>

<ul>
<li>自我介绍<br/>
中途会打断，所以准备的时候要把重点放在前面说，被打断了也不可惜。不用准备很长。</li>
<li>做过的项目<br/>
对他接触过的地方比较关注，或者要求描述大概。<br/>
可以事先准备下对每个项目的总体介绍，简短说明这个项目是什么。以免到时候说得没有条理。</li>
<li>白板编程<br/>
我修改次数太多了。最好先想好再下笔，尽量考虑全各种情况。<br/>
int->正 负 零，比如传长度，不要理所当然是个非零的数，要处理负数。<br/>
也许下次可以考虑先写测试用例再写程序，这样考虑的情况会多一些。 <br/>
最好在下笔前问清题意，对一些特殊情况怎么处理。</li>
<li>一些面试题、算法题和《编程之美》之类的还是要看的，有些巧妙的解法自己很难想到。</li>
<li>学习一下测试用例应该怎么写。</li>
<li>好多C和C++里的函数不记得了，要复习一下。</li>
<li>有些题目用“双指针”的模式可以很好解决，可以训练一下这方面的思维。</li>
</ul>


<h4>主要题目</h4>

<ul>
<li>string转int的函数实现</li>
<li>寻找单链表的倒数第k个元素</li>
<li>一个数组，其中元素为struct{a,b}，其中a是排序的，如果出现连续相同a，只保留最后一个元素。如果出现连续相同b，也只保留最后一个元素。大意是这样。&#8211;双指针</li>
</ul>


<h3>软件开发实习（N-zj）</h3>

<ul>
<li>presentation</li>
<li>做过的项目<br/>
要准备下自己在这个项目中最大成就，克服的难点和学到的知识</li>
<li>对公司的认识</li>
<li>实习时间<br/>
提前准备下怎么说</li>
<li>有什么问题要提问<br/>
要准备些题目，不然冷场</li>
<li>白板编程<br/>
有意识的选择数据类型，例如longlong等平时不常用的类型很多时候需要用来表示可能很大的数据</li>
<li>上机编程<br/>
我编程太慢了，来不及，要多练习，尽量能一次成型，不要太多次调试。<br/>
上机编程以能运行和可读性为首要要求，不要太追求算法高效。</li>
</ul>


<h4>主要题目</h4>

<ul>
<li>memcpy和strcpy实现</li>
<li>malloc和new的区别</li>
<li>各种关键字修饰的变量存储在堆？栈？其他？数据类型字节数</li>
<li>扑克牌的表示和洗牌函数</li>
<li>三角形向下相邻路径最大和</li>
<li>文件读写的程序</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[英文版Win7中文软件显示乱码的解决]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/04/11/solve-win7-chinese-gibberish/"/>
    <updated>2013-04-11T11:51:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/04/11/solve-win7-chinese-gibberish</id>
    <content type="html"><![CDATA[<p>新电脑装了英文版win7，但是安装国内一些中文软件时，名称和内容都会显示乱码。网上搜到解决方法如下：</p>

<!--more-->


<ul>
<li>打开控制面板 Control Panel</li>
<li>点击Clock, Language, and Region</li>
<li>点击Region and Language</li>
<li>点击Administrative选项卡</li>
<li>点击Change system locale按钮</li>
<li>将Current system locale改为：Chinese(Simplified, PRC)</li>
<li>重启计算机</li>
<li>新安装的软件不会出现乱码（实践中我以前安装的软件仍然会显示乱码，建议卸载重装）</li>
</ul>


<p>参考<a href="http://zhidao.baidu.com/question/219346693.html">http://zhidao.baidu.com/question/219346693.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chrome修改书签时崩溃问题的解决]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/04/11/solve-chrome-crashing/"/>
    <updated>2013-04-11T11:45:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/04/11/solve-chrome-crashing</id>
    <content type="html"><![CDATA[<p>很长一段时间内，我在Chrome中添加书签时总是很容易导致整个浏览器崩溃，但是最近发现另一台新装的电脑却没有这个问题。
在网上搜索后，找到了问题所在和解决方案。</p>

<!--more-->


<h2>具体问题</h2>

<p>点击Chrome地址栏的星形按钮添加书签没问题，但是如果此时想修改书签名称就会崩溃。<br/>
在书签栏上右键->修改，然后修改名称，也会崩溃。<br/>
唯一的方法是打开书签管理器，在其中修改。</p>

<h2>解决</h2>

<p>有道词典的“屏幕取词”功能和Chrome有冲突，关闭就好了。网上有说关闭“划词翻译”的，但我试了一下应该不是它的问题。</p>

<p>我平时本来就比较习惯用“划词翻译”，所以关闭“屏幕取词”影响不大。如果有这个习惯的话，Chrome扩展程序中有一个<code>Youdao Dictionary (by Gecko)</code>，支持双击查词和ctrl+鼠标查词，大概可以作为替代。不过我没有具体使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构与算法分析 读书笔记 4]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/03/18/data-structures-notes-4/"/>
    <updated>2013-03-18T23:53:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/03/18/data-structures-notes-4</id>
    <content type="html"><![CDATA[<p>第三章剩下的部分</p>

<!--more-->


<h2>第三章 表、栈和队列</h2>

<h3>3.4 向量的实现</h3>

<p>vector是基本类类型，这意味着不同于基本数组，vector可以复制并且其占用的内存可以自动回收（通过析构函数）</p>

<p>【？？？】程序第37行，为什么<code>reserve()</code>函数中判断的是<code>newCapacity &lt; theSize</code>而不是<code>newCapacity &lt; theCapacity</code>？</p>

<h3>3.5 表的实现</h3>

<p>在表的前端和末尾添加额外结点作为标志，称为哨兵结点。头部结点称为表头结点，末端的结点称为尾结点。使用好处是可以去掉很多特例，简化程序代码。</p>

<p>List中的代码摘抄</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">class</span> <span class="n">List</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="nl">private:</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">Node</span><span class="p">{...};</span>
</span><span class='line'><span class="nl">public:</span>
</span><span class='line'>    <span class="n">class</span> <span class="n">const_iterator</span><span class="p">{...};</span>
</span><span class='line'>    <span class="n">class</span> <span class="n">iterator</span><span class="o">:</span> <span class="n">public</span> <span class="n">const_iterator</span><span class="p">{...};</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="nl">private:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">theSize</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Node</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Node</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>定义前缀和后缀<code>operator++</code>的区别方法：给前缀指定空参数表，给后缀指定一个匿名的int参数。实现指出在许多可以选择使用前缀或后缀的情况下，使用前缀形式要快于使用后缀形式</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">const_iterator</span> <span class="n">operator</span><span class="o">++</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">const_iterator</span> <span class="n">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">const_iterator</span> <span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
</span><span class='line'>    <span class="o">++</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">old</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3.6 栈ADT</h3>

<p>栈的操作基本只有<code>push(),pop(),top()</code>，只有栈顶元素是可访问的。</p>

<p>栈是一个表，用数组和单向链表都可以实现，所以list和vector都支持栈，且操作为常量时间操作。</p>

<h4>栈的应用</h4>

<p>后缀或逆波兰记法：将<code>4.99*1.06 + 5.99 +6.99*1.06</code>（称为中缀式）记为<code>4.99 1.06 * 5.99 + 6.99 1.06 * +</code>。   当一个表达式以后缀记法给出时，没有必要知道任何优先规则。</p>

<p>可以用栈实现中缀式到后缀式的转换，主要原则是入栈操作符，读取新操作符时，从栈顶弹出直到遇到优先级更低的元素为止【需复习】</p>

<p>尾递归：在最后一行的递归调用，是极差的使用递归的例子。<br/>
通过将代码放到一个while循环中并用每个函数的一个参数代替递归调用，可以机械地消除尾递归。【？？？】不明白尾递归和其他递归的本质区别<br/>
递归总能够被彻底除去（编译器的工作），但提速的同时降低了程序的清晰性。</p>

<h3>3.7 队列ADT</h3>

<p>队列也是表。基本操作<code>enqueue(),dequeue()</code></p>

<p>循环数组：处理front或back到达数组尾端，而数组前面有很多空位的情况。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构与算法分析 读书笔记 3]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/03/14/data-structures-notes-3/"/>
    <updated>2013-03-14T23:58:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/03/14/data-structures-notes-3</id>
    <content type="html"><![CDATA[<p>3.1到3.3节。重点记录的是vector和list的操作函数，因为以前用的比较少</p>

<!--more-->


<h2>第三章 表、栈和队列</h2>

<h3>3.1 抽象数据类型ADT</h3>

<p>抽象数据类型（ADT）是带有一组操作的一些对象的集合。在ADT的定义中根本没有提到这组操作是如何实现的</p>

<h3>3.2 表ADT</h3>

<ul>
<li>简单数组实现：适合在末尾插入元素，之后只有数组访问<br/>
数组是静态分配的，但vector类允许在需要的时候将数组的大小增加一倍</li>
<li>链表实现：适合插入和删除在整个表中都发生<br/>
典型的链表保持至表的两端的链接，为了第一项的添加删除和末尾的新项添加为常量时间【应该是由于在两端操作数据最为常见】<br/>
双向链表，可以方便删除最后一项(方便找到倒数第二项)</li>
</ul>


<h3>3.3 STL中的向量和表</h3>

<p>标准模板库STL实现了公共数据结构，例如表ADT。这些数据结构称为集合（collection）或容器（container）</p>

<ul>
<li>vector给出了表ADT的可增长的数组实现。<br/>
优点：常量时间内可索引【findKth】，缺点：插入或删除代价昂贵（除非发生在末尾），查找效率低【find】</li>
<li>list提供表ADT的双向链表实现。<br/>
优点：插入和删除代价小，缺点：不容易索引，查找效率低</li>
</ul>


<p>常用方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">clear</span><span class="p">();</span><span class="c1">//删除容器内的所有元素</span>
</span><span class='line'><span class="n">bool</span> <span class="n">empty</span><span class="p">();</span>
</span><span class='line'><span class="c1">//以下四个都为常量时间</span>
</span><span class='line'><span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">Object</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span><span class="c1">//在表的末尾添加x</span>
</span><span class='line'><span class="kt">void</span> <span class="n">pop_back</span><span class="p">();</span><span class="c1">//删除表的末尾对象</span>
</span><span class='line'><span class="k">const</span> <span class="n">Object</span> <span class="o">&amp;</span> <span class="n">back</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'><span class="k">const</span> <span class="n">Object</span> <span class="o">&amp;</span> <span class="n">front</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//仅针对list</span>
</span><span class='line'><span class="kt">void</span> <span class="n">push_front</span><span class="p">(</span><span class="k">const</span> <span class="n">Object</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="n">pop_front</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//仅针对vector</span>
</span><span class='line'><span class="n">Object</span> <span class="o">&amp;</span> <span class="n">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">idx</span><span class="p">);</span><span class="c1">//不包含边界检测</span>
</span><span class='line'><span class="n">Object</span> <span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">);</span><span class="c1">//包含边界检测</span>
</span><span class='line'><span class="kt">int</span> <span class="n">capacity</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span><span class="c1">//返回vector的内部容量</span>
</span><span class='line'><span class="kt">void</span> <span class="n">reserve</span><span class="p">(</span><span class="kt">int</span> <span class="n">new</span> <span class="n">Capacity</span><span class="p">);</span><span class="c1">//设定vector的新容量</span>
</span></code></pre></td></tr></table></div></figure>


<h4>迭代器iterator</h4>

<p>通过内置类型iterator来标记位置，例如<code>list&lt;string&gt;::iterator</code>和<code>vector&lt;int&gt;::iterator</code></p>

<p>相关方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">iterator</span> <span class="n">begin</span><span class="p">();</span><span class="c1">//返回指向容器第一项的适当迭代器</span>
</span><span class='line'><span class="n">iterator</span> <span class="n">end</span><span class="p">();</span><span class="c1">//指向容器的终止标志，容器中最后一项的后面的位置，边界之外</span>
</span><span class='line'><span class="n">itr</span><span class="o">++</span><span class="p">;</span> <span class="o">++</span><span class="n">itr</span><span class="p">;</span>
</span><span class='line'><span class="o">*</span><span class="n">itr</span><span class="p">;</span><span class="c1">//返回itr指定位置的对象的引用</span>
</span><span class='line'><span class="n">itr1</span> <span class="o">==</span> <span class="n">itr2</span><span class="p">;</span> <span class="n">itr1</span> <span class="o">!=</span> <span class="n">itr2</span><span class="p">;</span><span class="c1">//是否指向同一个位置</span>
</span><span class='line'><span class="n">iterator</span> <span class="n">insert</span><span class="p">(</span><span class="n">iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">Object</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span><span class="c1">//返回插入项位置。对list常量时间，对vector不是</span>
</span><span class='line'><span class="n">iterator</span> <span class="n">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">pos</span><span class="p">);</span><span class="c1">//返回pos下一个元素的位置，操作完成后pos失效</span>
</span><span class='line'><span class="n">iterator</span> <span class="n">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">start</span><span class="p">,</span> <span class="n">iterator</span> <span class="n">end</span><span class="p">);</span><span class="c1">//删除的元素直到但不包括end</span>
</span></code></pre></td></tr></table></div></figure>


<p>【注意错误】我写的对表使用erase的代码</p>

<figure class='code'><figcaption><span>WRONG!!!</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">//1.erase后itr失效，不能继续使用了</span>
</span><span class='line'><span class="c1">//2.使用itr+2操作会超过lst.end()，越界</span>
</span><span class='line'><span class="c1">//...是否还有其他错误？</span>
</span><span class='line'>
</span><span class='line'><span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">Container</span><span class="o">&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">removeEveryOtherItem</span><span class="p">(</span><span class="n">Container</span> <span class="o">&amp;</span> <span class="n">lst</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span><span class="p">(</span><span class="n">Container</span><span class="o">::</span><span class="n">iterator</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">lst</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">itr</span> <span class="o">!=</span> <span class="n">lst</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">itr</span><span class="o">=</span><span class="n">itr</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'>        <span class="n">lst</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">itr</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>STL也包含const_iterator，*const_iterator会返回常量引用，不能成为左值</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span>
</span><span class='line'><span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span>
</span></code></pre></td></tr></table></div></figure>


<p>两个版本的begin可以在同一个类里，因为方法的定常性被认为是标号的一部分
如果对非常量容器调用begin，返回iterator的版本被调用。如果对常量容器调用，返回const_iterator</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『转载整理』javascript constructor 详解]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/03/11/javascript-constructor-explanation/"/>
    <updated>2013-03-11T10:43:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/03/11/javascript-constructor-explanation</id>
    <content type="html"><![CDATA[<h2>constructor简介</h2>

<ul>
<li>constructor 属性是每个具有原型的对象的原型成员。</li>
<li>这包括除 Global 和 Math 对象之外的所有内部 JavaScript 对象。</li>
</ul>


<!--more-->


<p>用法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// A constructor function.</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">MyObj</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">String</span><span class="p">(</span><span class="s2">&quot;Hi&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">==</span> <span class="nb">String</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="s2">&quot;Object is a String.&quot;</span><span class="p">);</span>
</span><span class='line'><span class="nb">document</span><span class="p">.</span><span class="nx">write</span> <span class="p">(</span><span class="s2">&quot;&lt;br /&gt;&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyObj</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">==</span> <span class="nx">MyObj</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">document</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="s2">&quot;Object constructor is MyObj.&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Output:</span>
</span><span class='line'><span class="c1">// Object is a String.</span>
</span><span class='line'><span class="c1">// Object constructor is MyObj.</span>
</span></code></pre></td></tr></table></div></figure>


<h2>constructor和prototype</h2>

<ul>
<li><code>Foo.prototype.constructor</code>是系统(浏览器)创建的，默认指向Foo。</li>
<li>对象b的constructor属性是通过找到<code>b.__proto__.constructor</code>(即<code>Foo.prototype.constructor</code>)访问的，存在于原型链中，而非对象本身属性</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">// 构造函数</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">Foo</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//Foo.prototype存储了新创建对象的原型的引用，我们可以使用它来定义共享的属性或方法 </span>
</span><span class='line'><span class="nx">Foo</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'><span class="nx">Foo</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">calculate</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">z</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">z</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
</span><span class='line'>  <span class="c1">// Foo.prototype 会自动创建一个特别的属性constructor指向构造函数Foo</span>
</span><span class='line'>  <span class="c1">// 对象b和c可以通过代理找到此构造函数</span>
</span><span class='line'>  <span class="nx">b</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nx">Foo</span><span class="p">,</span> <span class="c1">// true</span>
</span><span class='line'>  <span class="nx">c</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nx">Foo</span><span class="p">,</span> <span class="c1">// true</span>
</span><span class='line'>  <span class="nx">Foo</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nx">Foo</span> <span class="c1">// true</span>
</span><span class='line'><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上对象的关系如下图所示
<img src="http://ziwu1216.github.com/images/javascript-constructor-explanation-relation.jpg" title="关系示意图" alt="图片加载失败:("></p>

<h2>constructor易变</h2>

<p>constructor易变，是因为函数的prototype属性容易被更改。例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">F</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'><span class="nx">_name</span><span class="o">:</span> <span class="s1">&#39;Eric&#39;</span><span class="p">,</span>
</span><span class='line'><span class="nx">getName</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'><span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_name</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">F</span><span class="p">();</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nx">F</span><span class="p">);</span> <span class="c1">// output false</span>
</span><span class='line'>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span><span class="p">);</span><span class="c1">//output true </span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">);</span><span class="c1">// also output true  </span>
</span></code></pre></td></tr></table></div></figure>


<p>F的原型被开发者重写了，这种方式将原有的prototype对象用一个对象的字面量{}来代替。而新建的对象{}只是Object的一个实例，系统（浏览器）在解析的时候并不会在{}上自动添加一个constructor属性，因为这是function创建时的专属操作，仅当你声明函数的时候解析器才会做此动作。<br/>
因为{}是创建对象的一种简写，所以{}相当于是new Object()。因为{}是Object的实例，而Object.prototype上有一个指向Object本身的constructor属性。所以可以看出f.constructor其实就是Object.prototype的constructor，</p>

<p>一个解决办法就是手动恢复他的constructor：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">function</span> <span class="nx">F</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'><span class="nx">constructor</span><span class="o">:</span> <span class="nx">F</span><span class="p">,</span> <span class="cm">/* reset constructor */</span>
</span><span class='line'><span class="nx">_name</span><span class="o">:</span> <span class="s1">&#39;Eric&#39;</span><span class="p">,</span>
</span><span class='line'><span class="nx">getName</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'><span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_name</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">F</span><span class="p">();</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nx">F</span><span class="p">);</span> <span class="c1">// output true this time ^^ </span>
</span></code></pre></td></tr></table></div></figure>


<hr />

<p>参考链接：<br/>
<a href="http://msdn.microsoft.com/zh-cn/library/c1hcx253.aspx">constructor 属性 (JavaScript)</a><br/>
<a href="http://blog.csdn.net/wanghui499917270/article/details/7171542">V8引擎实现标准ECMA-262（三）</a><br/>
<a href="http://www.douban.com/group/topic/23280359/">揭开constructor属性的神秘面纱</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构与算法分析 读书笔记 2]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/03/10/data-structures-notes-2/"/>
    <updated>2013-03-10T22:39:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/03/10/data-structures-notes-2</id>
    <content type="html"><![CDATA[<p>半个多月前就记了，一直都没整理……第二章</p>

<!--more-->


<h2>第二章 算法分析</h2>

<p>算法是为求解一个问题需要遵循的、被清楚地指定的简单指令的集合。</p>

<h3>2.1 数学基础</h3>

<p><img src="http://ziwu1216.github.com/images/data-structures-notes-2-def.PNG" title="定义" alt="图片加载失败 :(">
这些定义是相对增长率的比较。</p>

<ul>
<li>大O，f是T的上界</li>
<li>omega，g是T的下界</li>
<li>theta，表示严格的增长率相等。<br/>
【？？？】【为什么定义四是对所有常数？】</li>
</ul>


<p>重要法则：<img src="http://ziwu1216.github.com/images/data-structures-notes-2-rule.PNG" title="法则" alt="图片加载失败 :("><br/>
典型增长率：<img src="http://ziwu1216.github.com/images/data-structures-notes-2-rate.PNG" title="典型增长率" alt="图片加载失败 :("></p>

<p>不要将常数或低阶项放进大O</p>

<p>可以通过计算lim（N→+∞）f(N)/g(N)来比较函数的相对增长率（洛必达法则，分子分母求导）</p>

<h3>2.3 要分析的问题</h3>

<p>分析程序的运行时间，一般需要最坏情况而非平均情况，一是因为对所有输入提供界限，二是因为平均计算起来困难。</p>

<p>高效算法中，数据读入常常成为瓶颈。</p>

<h3>2.4 运行时间计算</h3>

<p>一般法则</p>

<ul>
<li>法则1： for循环，时间至多是该循环内语句（包括测试）的运行时间乘以迭代的次数</li>
<li>法则2： 嵌套循环，从里向外分析【也是分析运行时间的基本策略】，一组嵌套循环内部的一条语句总的运行时间，为该语句时间乘以该组所有循环的大小的乘积</li>
<li>法则3： 顺序语句，将各个语句的运行时间求和</li>
<li>法则4： if/else语句，不超过判断语句时间加分支中运行较长的时间之和</li>
</ul>


<p>递归和调用的运行时间分析举例【！！！需复习】<br/>
令T(N)为求解大小为N的问题所花费时间，基准条件得到T(0)，T(1)等，迭代得到关系式如T(N) = 2T(N/2) + O(N),求解。【？？？】【如何求解】</p>

<h4>最大子序列和问题的求解</h4>

<p>多重求和公式计算算法复杂度【！！！需复习】</p>

<p>递归算法，“分治”策略，把整组数据分为左右两个子序列，考虑可能出现在左边，右边，或横跨左右。【！！！需编码】  <br/>
递归函数调用的一般形式是传递输入数组以及左边界和右边界，它们界定了数组要被处理的部分。<br/>
【在递归中，设计传递参数很重要，书中的例子避免了子序列的拷贝，比我开始设计的参数好很多】</p>

<p>联机算法：在任意时刻，算法都能对它已经读入的数据给出问题的正确答案。仅需要常量空间并以线性时间运行的算法几乎是完美的算法。</p>

<h4>O(logN)</h4>

<p>如果一个算法用常数时间将问题的大小削减为其一部分（通常是1/2），那么该算法就是O(logN)的。</p>

<ul>
<li>二分搜索</li>
<li>欧几里得算法</li>
<li>幂运算</li>
</ul>


<h4>检验分析</h4>

<p>方法一是编程并比较N扩大一倍后实际运行时间与分析是否匹配。很多时候很困难。</p>

<p>方法二：验证是否O(f(N))，对N的某个范围计算T(N)/f(n)，T(N)是观察到的运行时间。（收敛于正常数，收敛于0，发散）【？？？】【什么是“用2的倍数隔开”】</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『转载整理』javascript prototype 详解]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/03/10/javascript-prototype-explanation/"/>
    <updated>2013-03-10T00:05:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/03/10/javascript-prototype-explanation</id>
    <content type="html"><![CDATA[<p>没有系统学过JavaScript语言，就要开始对JavaScript引擎做些改动，因此不可避免地撞上了JavaScript的一些独特的特性，例如prototype。</p>

<p>只是最基本的概念理清，不包含复杂的编程模式之类。</p>

<!--more-->


<h2><code>__proto__</code>属性和原型链</h2>

<ul>
<li><code>__proto__</code>是每个JavaScript对象的私有属性，指向对象的原型。原型也是对象。</li>
<li>原型链是指对象上的<code>__proto__</code>链。</li>
<li>属性查找通过原型链进行。</li>
</ul>


<p>这是一个简单的对象定义。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">x</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">y</span><span class="o">:</span> <span class="mi">20</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个结构定义了两个显式属性和一个隐式属性 <code>__proto__</code>，它指向foo的原型
<img src="http://ziwu1216.github.com/images/javascript-prototype-explanation-proto.gif" title="foo对象" alt="图片加载失败 :("></p>

<p>设想两个对象有一些属性不同而其他所有属性都相同的情况，很明显，设计良好的系统应当代码重用，而不是在一个对象中重复定义。
ECMAScript没有类的概念，它是通过原型链来达到同样的效果的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">x</span><span class="o">:</span> <span class="mi">10</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">calculate</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">z</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">z</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">y</span><span class="o">:</span> <span class="mi">20</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">__proto__</span><span class="o">:</span> <span class="nx">a</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">y</span><span class="o">:</span> <span class="mi">30</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">__proto__</span><span class="o">:</span> <span class="nx">a</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// call the inherited method</span>
</span><span class='line'><span class="nx">b</span><span class="p">.</span><span class="nx">calculate</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span> <span class="c1">// 60</span>
</span><span class='line'><span class="nx">c</span><span class="p">.</span><span class="nx">calculate</span><span class="p">(</span><span class="mi">40</span><span class="p">);</span> <span class="c1">// 80</span>
</span></code></pre></td></tr></table></div></figure>


<p>b和c可以访问a中定义的calculate方法，这就是通过原型链达到的。
规则很简单：如果一个方法或者属性不在一个对象本身里面，那么就尝试在原型链中查找。如果在原型中没有找到，那么就在原型的原型中查找，以此类推查找整个原型链。最先发现的属性或者方法最先使用。如果在整个原型链中都没有找到，将返回undefined值。</p>

<p>注意，那个在继承方法中的this值是原始的对象（b和c），而不是定义这个方法的对象（a），在这个例子中，this.y是b和c中的y，而不是a中的。然而this.x来自于a，但这是通过原型链机制得到的（x本来应该是从b和c中获得，但他们本身没有）</p>

<p>如果一个对象没有显式指定原型，那么默认的<code>__proto__</code>值是Object.prototype。Object.prototype本身也有一个<code>__proto__</code>，它是原型链中的最后一个，其值为null
<img src="http://ziwu1216.github.com/images/javascript-prototype-explanation-prototype-chain.gif" title="原型链" alt="图片加载失败 :("></p>

<h2>prototype和<code>__proto__</code></h2>

<ul>
<li>prototype是JavaScript函数具有的属性</li>
<li>new的时候会把函数的prototype赋给对象的<code>__proto__</code>属性。</li>
</ul>


<p>以下是一个简单的new的过程</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">Person</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="p">};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以把new的过程拆分成三步：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">p</span><span class="o">=</span><span class="p">{};</span>
</span><span class='line'><span class="nx">p</span><span class="p">.</span><span class="nx">__proto__</span><span class="o">=</span><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
</span><span class='line'><span class="nx">Person</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>证明一下第二步。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">Person</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="p">};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">();</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">===</span> <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span><span class="c1">//true,ie不支持访问此私有属性</span>
</span></code></pre></td></tr></table></div></figure>


<h2>prototype</h2>

<p>在学习prototype(原型)的时候，我们首先要搞明白这样两个规则：</p>

<ul>
<li>使用原型可以大量减少每个对象对内存的需求量，因为对象可以继承许多属性。</li>
<li>即使属性在对象被创建之后才被添加至原型中，对象也能够继承这些属性。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">//创建一个构造函数 “用户”</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">User</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//实例化一个用户——&gt;老张</span>
</span><span class='line'><span class="kd">var</span> <span class="err">老张</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">User</span><span class="p">(</span><span class="s1">&#39;老张&#39;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//弹窗显示老张的名字</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="err">老张</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//定义原型，注意这里对象“老张”已经被实例化了</span>
</span><span class='line'><span class="nx">User</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">favchannel</span> <span class="o">=</span> <span class="s1">&#39;CCAV&#39;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//弹窗显示老张最喜欢的电视台</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="err">老张</span><span class="p">.</span><span class="nx">favchannel</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>读属性时，顺序是：老张——>User.prototype——>Object.prototype</p>

<p>只有读属性的时候才会使用prototype，写属性的时候是不会用到prototype的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">//老李是一个新的用户</span>
</span><span class='line'><span class="kd">var</span> <span class="err">老李</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">User</span><span class="p">(</span><span class="s1">&#39;老李&#39;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//老李喜欢小电影</span>
</span><span class='line'><span class="err">老李</span><span class="p">.</span><span class="nx">favchannel</span> <span class="o">=</span> <span class="s1">&#39;JAPANTV&#39;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//弹窗显示JAPANTV</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="err">老李</span><span class="p">.</span><span class="nx">favchannel</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//弹窗显示老张还是中意CCAV</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="err">老张</span><span class="p">.</span><span class="nx">favchannel</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>复杂点的原型链</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">Person</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="p">};</span>
</span><span class='line'><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">Say</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;Person say&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">Salary</span> <span class="o">=</span> <span class="mi">50000</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">Programmer</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="p">};</span>
</span><span class='line'><span class="nx">Programmer</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">();</span>
</span><span class='line'><span class="nx">Programmer</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">WriteCode</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;programmer writes code&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="nx">Programmer</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">Salary</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Programmer</span><span class="p">();</span>
</span><span class='line'><span class="nx">p</span><span class="p">.</span><span class="nx">Say</span><span class="p">();</span>
</span><span class='line'><span class="nx">p</span><span class="p">.</span><span class="nx">WriteCode</span><span class="p">();</span>
</span><span class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Salary</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>详细推导：
<code>var p=new Programmer()</code> => <code>p.__proto__=Programmer.prototype</code>;</p>

<p><code>Programmer.prototype=new Person()</code> => <code>Programmer.prototype.__proto__=Person.prototype</code>;</p>

<p>=> <code>p.__proto__.__proto__=Person.prototype</code></p>

<h2>Next</h2>

<p>我还看到一张更复杂的图，不过要理解下constructor属性，下次继续</p>

<hr />

<p>参考链接：</p>

<p><a href="http://blog.csdn.net/wanghui499917270/article/details/7170207">V8引擎实现标准ECMA-262（二）</a></p>

<p><a href="http://www.cnblogs.com/kym/archive/2010/01/09/1643062.html">Javascript学习笔记7——原型链的原理</a></p>

<p><a href="http://www.xiaoxiaozi.com/2009/06/29/995/">JavaScript prototype原型对象</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构与算法分析 读书笔记 1]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/02/09/data-structures-notes-1/"/>
    <updated>2013-02-09T13:16:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/02/09/data-structures-notes-1</id>
    <content type="html"><![CDATA[<p>看扫描pdf真心累啊，可是家里没有纸质书。。。</p>

<p>书籍信息：数据结构与算法分析 C++描述（第3版）Mark Allen Weiss 著；张怀勇等译；人民邮电出版社</p>

<!--more-->


<h2>第一章 引论</h2>

<h3>1.1 本书讨论的内容</h3>

<p>问题1：选择问题。设有一组N个数，要确定其中第k个最大的数</p>

<p>问题2：输入由一个二维字母数组和一个单词表组成，找出水平、垂直或对角方向放置的单词</p>

<h3>1.2 数学知识复习</h3>

<ul>
<li>几何级数：<img src="http://ziwu1216.github.com/images/data-structures-notes-1-jihe.PNG" title="几何级数" alt="图片加载失败 :("></li>
<li>算术级数：<img src="http://ziwu1216.github.com/images/data-structures-notes-1-suanshu.PNG" title="算术级数" alt="图片加载失败 :("></li>
<li><img src="http://ziwu1216.github.com/images/data-structures-notes-1-gaojie.PNG" title="高阶" alt="图片加载失败 :("></li>
<li>调和数：<img src="http://ziwu1216.github.com/images/data-structures-notes-1-tiaohe.PNG" title="调和数" alt="图片加载失败 :("></li>
</ul>


<p>归纳法：第一步证明基准情形（对于某个或某些值），接着归纳假设（k），然后证明k+1。必须k有限。</p>

<h3>1.3 递归的简单介绍</h3>

<p>递归：需要处理基准情况base case和递归调用。</p>

<p>递归的基本准则</p>

<ul>
<li>基准情形</li>
<li>不断推进：递归调用将一直进行到基准情形出现为止，若永远不能到达基准情形，则出错。</li>
<li>设计法则：假设所有的递归调用都能运行。不追踪实际的递归调用序列。</li>
<li>合成效益法则：在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。</li>
</ul>


<h3>1.4 C++类</h3>

<p>构造函数中，const数据成员和自定义类数据成员，必须在初始化列表里初始化</p>

<p>所有单参数的构造函数都必须是explicit的，以避免后台的类型转换</p>

<p>C++标准定义了两个类vector和string，意在替代内置数组和字符串，增加了=复制、大小确定、==比较等，使用他们几乎总是较好的选择</p>

<h3>1.5 C++细节</h3>

<p>指针最好进行初始化，可以初始化为NULL</p>

<p>按值调用适用于不被函数更改的小对象，按常量引用调用适用于不被函数更改的大对象，引址调用适用于所有可以被函数更改的对象</p>

<p>如果返回值是类类型的，可以使用按常量引用返回以节省复制的开销，但必须保证返回语句中的表达式在函数返回时不被销毁。</p>

<p>三个默认特殊函数：</p>

<ul>
<li>析构函数</li>
<li>复制构造函数：IntCell B = C； IntCell B(C); 按值调用传递时；按值返回时。<br/>
每个数据成员依次复制，若有类对象的数据成员，调用数据成员的复制构造函数</li>
<li>operator=</li>
</ul>


<p>有指针数据成员时，默认特殊函数会造成内存泄露和浅复制</p>

<h3>1.6 模板</h3>

<p>函数模板可以应需要而自动扩展&#8211;>代码膨胀</p>

<p>模板实参可以使用任何类类型，因此尽量使用常量引用</p>

<p>类模板：例如数据成员类型不确定</p>

<p>函数对象：定义一个包含零个数据和一个成员函数的类。使用operator(),调用cmp.operator()(x,y)可以简写为cmp(x,y)，看上去就像函数调用，因此operator()被称为函数调用操作符</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">CaseInsensitiveCompare</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span> <span class="k">return</span> <span class="n">stricmp</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">rhs</span><span class="p">.</span><span class="n">c_str</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Object</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Comparator</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">const</span> <span class="n">Object</span> <span class="o">&amp;</span> <span class="n">findMax</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">arr</span><span class="p">,</span> <span class="n">Comparator</span> <span class="n">isLessThan</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="n">isLessThan</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">maxIndex</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">findMax</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">CaseInsensitiveCompare</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>1.7 使用矩阵</h3>

<p>矩阵matrix类的构造：使用向量的向量，重载operator[]。需要有两个版本的operator[],因为<code>to[i] = from[i]</code>,需要返回一个常量引用给from，返回一个普通引用给to。</p>

<p>【C++这样重载可以正常工作吗？为什么知道调用哪个operator[]？】<br/>
【更新：我在<a href="http://ziwu1216.github.com/blog/2013/03/14/data-structures-notes-3/">第三章</a>里看到了解释】</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">row</span><span class="p">)</span> <span class="k">const</span>
</span><span class='line'>  <span class="p">{</span> <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="n">row</span><span class="p">];</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">row</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span> <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="n">row</span><span class="p">];</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">array</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于毕业设计]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/01/11/about-graduation-project/"/>
    <updated>2013-01-11T23:02:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/01/11/about-graduation-project</id>
    <content type="html"><![CDATA[<p>这周听了师兄师姐们的毕业设计答辩，老师给的一些意见都很中肯也很有意义。</p>

<!--more-->


<h2>关于论文编排</h2>

<ul>
<li>论文中要对涉及到的基本概念进行阐释，因为不是所有人都熟悉你做的内容，但是篇幅也不能太多</li>
<li>用到的图像要清晰美观，如果是照片之类的请保持微笑:)</li>
<li>论文排版要注意

<h2>关于论文内容</h2></li>
<li>测试集要尽量大，这样结论才有说服力</li>
<li>在优化时，第一个考虑的其实是根据实际情况筛选，排除不需要进行处理的情况，这是最彻底的减轻运算量的方法</li>
<li>经典算法的改进效果要实事求是，大家都知道经典算法的情况，所以改进效果太好的话容易引起质疑，必须要有强力的理论和测试支撑才行</li>
<li><p>对自己成果的描述口吻要客观，分清“提出了”和“改进了”</p>

<h2>关于ppt演讲</h2>

<p>以下这些就是我自己的感觉了</p></li>
<li><p>演讲时的语速语调真的对演讲效果有很大影响的，语调振奋一点可能比较好，平淡无起伏的声音比较像读书，让人昏昏欲睡</p></li>
<li>内容和时间要把握好，宁可提前删减一些内容，也不要用加快语速的方法，听众会跟不上思路。<br/>
我自己好像是习惯快语速，还总想略讲一些内容，不管时间够不够，不知道是不是由于紧张，一定要有意识地改进</li>
<li>检查ppt，不要出现错别字等等，否则容易让人觉得自己对这次演讲重视不够</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hello octopress 2：流程记录]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/01/05/hello-octopress-2/"/>
    <updated>2013-01-05T18:01:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/01/05/hello-octopress-2</id>
    <content type="html"><![CDATA[<p>打了一段时间页游，好久不更新这里了，果然意志不坚啊。再写的时候生疏了很多，所以简单记录一下整个流程，方便以后参考。</p>

<!--more-->


<p>进入octopress的目录</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd /directory/to/octopress</span></code></pre></td></tr></table></div></figure>


<p>使配置生效。这个应该可以改变写配置命令的地方使其自动生效吧，我懒得改了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>source ~/.bash_profile</span></code></pre></td></tr></table></div></figure>


<p>生成新博客，注意方括号之前不要留空格</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_post["title"]</span></code></pre></td></tr></table></div></figure>


<p>修改生成的页面，其中category的写法是这样滴</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Multiple categories example 1
</span><span class='line'>categories: [CSS3, Sass, Media Queries]</span></code></pre></td></tr></table></div></figure>


<p>写好后在本机4000端口实时预览</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake preview</span></code></pre></td></tr></table></div></figure>


<p>生成文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake generate </span></code></pre></td></tr></table></div></figure>


<p>发布文件到github</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake deploy </span></code></pre></td></tr></table></div></figure>


<p>搞定！</p>

<p>可以不时备个份</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add .
</span><span class='line'>git commit -m "changes"
</span><span class='line'>git push origin source</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Primer 读书笔记 1]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/01/05/c-plus-plus-primer-notes-1/"/>
    <updated>2013-01-05T15:50:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/01/05/c-plus-plus-primer-notes-1</id>
    <content type="html"><![CDATA[<p>最近在看一些源代码，立刻发现自己的C++功底相当的弱，于是决定静心开始读经典的《C++ Primer》中文版，开头似乎是入门的知识，所以决定做些笔记，偶尔加些自己的验证。这样以后直接翻笔记就行了。笔记很零碎，感觉很适合C++考试的选择题……汗。</p>

<p>书籍信息：C++ Primer 中文版（第4版）Stanley B. Lippman, Josee Lajoie, Barbara E. Moo 著；李师贤等译；人民邮电出版社</p>

<p>以下为第一章笔记。</p>

<!--more-->


<h2>第一章</h2>

<h3>1.1</h3>

<ul>
<li><p>返回值必须和函数的返回类型相同，或者可以转换成函数的返回类型<br/>
【需要返回double时可以return int，反之不行】</p></li>
<li><p>常见C++程序文件后缀： *.cc *.cxx *.cpp *.cp *.C</p></li>
</ul>


<h3>1.2</h3>

<ul>
<li><p>iostream库的基础是两种命名为istream和ostream的类型，分别表示输入流和输出流。标准库定义了4个IO对象，处理输入时使用命名为cin的istream类型对象，也称为标准输入。处理输出时使用命名为cout的ostream类型对象，也称为标准输出。另外，cerr和clog都是ostream对象。<br/>
【都忘了原来istream是类啊】</p></li>
<li><p>输出操作符&lt;&lt;：接受两个操作数，左操作数必须是ostream对象，右操作数是要输出的值，返回输出流本身（即左操作数）。输入操作符类推。</p></li>
<li><p>endl称为操纵符（manipulator），换行，刷新与设备相关联的缓冲区，用户立即看到写入到流中的输出。忘记刷新输出流可能会造成输出停留在缓冲区中，如果程序崩溃，将会导致对程序崩溃位置的错误推断。</p></li>
<li><p>使用命名空间，可以避免由于无意中使用了与库中所定义名字相同的名字而引起冲突。从而我们可以使用与标准库相同的名字。</p></li>
<li><p>空格符不允许出现在预处理指示中<br/>
【<br/>
预处理是指在编译前所作的工作。例如#include, #define等<br/>
带参宏定义中，宏名和形参表之间不能有空格出现<br/>
例如<code>#define MAX(a,b) (a&gt;b)?a:b</code>不能写成<code>#define MAX (a,b) (a&gt;b)?a:b</code><br/>
】</p></li>
</ul>


<h3>1.3</h3>

<ul>
<li>注释对不可嵌套。临时忽略一段代码更好的方法，是用编辑器在要忽略的每一行代码前面插入单行注释//，这样就无需担心是否已包含注释对/**/</li>
</ul>


<h3>1.4</h3>

<ul>
<li><p>for(int val = 1; val &lt;= 10; ++ val)执行顺序：</p>

<ol>
<li>创建val并初始化为1</li>
<li>测试val是否&lt;= 10<br/>
【<br/>
第一次进入时就要测试！！<br/>
<code>for(int val = 11; val &lt;= 10; ++ val) cout&lt;&lt;val&lt;&lt;endl;</code><br/>
不会有输出<br/>
】</li>
<li>如果是，则执行for循环体；如果不是，则退出循环</li>
<li>Val递增</li>
<li>重复第2步的测试</li>
</ol>
</li>
<li><p>读入未知数目的输入<br/>
<code>while(cin &gt;&gt; value) sum += value;</code><br/>
测试cin，即测试流的状态。如果流有效，测试成功。遇到文件结束符或无效输入【如类型和value不符合】，条件失败。<br/>
【</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">value</span><span class="p">)</span>
</span><span class='line'>      <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">value</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在输入<code>1 2 3 回车</code>后会显示</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
</span><span class='line'><span class="mi">1</span>
</span><span class='line'><span class="mi">2</span>
</span><span class='line'><span class="mi">3</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以继续输入。<br/>
在输入<code>1 2 3 ^Z 回车</code>或<code>1 2 3 str 回车</code>后会显示</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="n">str</span>
</span><span class='line'><span class="mi">1</span>
</span><span class='line'><span class="mi">2</span>
</span><span class='line'><span class="mi">3</span>
</span><span class='line'><span class="err">请按任意键继续</span><span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>不可以继续输入。<br/>
回车的作用：windows是行缓冲，只有按下回车后，系统才会将输入的这一行数据存放到程序的输入缓存中。<br/>
】</p>

<ul>
<li>文件结束符，windows下ctrl+z，unix下ctrl+d</li>
</ul>


<h3>1.5</h3>

<ul>
<li>标准库的头文件用&lt;>， 非标准库的文件用””</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hello octopress]]></title>
    <link href="http://ziwu1216.github.com/blog/2012/11/28/hello-octopress/"/>
    <updated>2012-11-28T13:56:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2012/11/28/hello-octopress</id>
    <content type="html"><![CDATA[<p>理论上来说，这才应该是我第一篇博客……描述博客的搭建过程。只是作为一个博客菜鸟 + octopress菜鸟 + linux菜鸟，我其实也是依葫芦画瓢，照着官网的步骤和别人的博客一步一步做的。所以过程就不赘述了，列一下我的主要参考网站和解决的一些小问题吧</p>

<!--more-->


<h2>主要参考网站</h2>

<ul>
<li><p><a href="http://octopress.org/">octopress官网</a></p>

<p>  官网的文档写的非常简明清晰，其实不需要其他教程，基本上照着做就行了</p></li>
<li><p><a href="http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/">搭建参考</a></p>

<p>  这篇博文总结了根据国内需求进行的一些配置，比如删除twitter和增加分享到国内微博等等</p></li>
<li><p><a href="http://wowubuntu.com/markdown/#link">markdown语法</a></p>

<p>  我是最近用github之后才开始接触markdown的，所以还是经常要查一下语法</p></li>
</ul>


<h2>遇到的问题</h2>

<h3>用rbenv安装ruby</h3>

<p>我不得不说，如果没有特殊理由的话，还是用rvm吧……万一遇到问题，网上可以搜到很多解决方法。我没了解过ruby，随意挑了rbenv来安装，过程实在是纠结……</p>

<h4>1.ruby的版本</h4>

<p>官网上在<a href="http://octopress.org/docs/setup/rbenv/">Installing Ruby With Rbenv</a>页面说用<code>rbenv install 1.9.3-p0</code>安装ruby，但我clone的octopress项目中<code>.rbenv-version</code>文件其实写的是<code>1.9.3-p194</code>，所以会提示版本未安装。直接按照<code>.rbenv-version</code>里要求的版本安装就行。</p>

<h4>2.缺少zlib依赖</h4>

<pre><code>sudo apt-get install zlib1g-dev
</code></pre>

<h4>3.缺少openssl依赖</h4>

<p>这个问题纠结了我半天，反复卸载安装了好几次。网上的解决方案大多是针对rvm的，搜寻资料也很痛苦。最后在<a href="https://gist.github.com/1200482">这里</a>找到了解决方案</p>

<p>安装依赖库，我开始只安装了openssl，是不够的</p>

<pre><code>sudo apt-get install openssl
sudo apt-get install libssl-dev
sudo apt-get install libssl0.9.8
</code></pre>

<p>安装rbenv，按照官网来就行</p>

<p>安装ruby-build</p>

<pre><code>git clone git@github.com:sstephenson/ruby-build.git
cd ruby-build
./install.sh
</code></pre>

<p>然后才能安装ruby</p>

<pre><code>ruby-build 1.9.3-p194 ~/.rbenv/versions/1.9.3-p194 --with-openssl-dir=/usr/local
rbenv rehash
</code></pre>

<p>如果要设置全局ruby的版本的话可以用<code>rbenv global 1.9.3-p194</code></p>

<p>进入octopress文件夹下可以查询ruby是否安装成功<code>ruby -v</code></p>

<p>检查下openssl是否正常，应该返回<code>true</code></p>

<pre><code>irb
require 'openssl' 
</code></pre>

<h3>用root用户<code>rake deploy</code>时提示ssh密钥错误</h3>

<p>这大概是只有我这种小白才会犯的错误……是因为root用户和普通用户存放密钥的文件夹不一样，所以尽量用同一个用户操作，或者把密钥拷贝一份</p>

<h3>添加Jiathis分享插件时显示一小块空白</h3>

<p>参考<a href="http://geeksavetheworld.com/blog/2012/11/05/add-jiathis-to-octopress-blog/">这篇博文</a></p>

<h3>在侧栏添加分类列表</h3>

<p>我主要是觉得侧栏太空了……参考<a href="http://codemacro.com/2012/07/18/add-category-list-to-octopress/">这篇博文</a></p>

<h2>其他</h2>

<p>其实对octopress博客的个性化还有很多，可以搜到很多教程，只是我比较懒。作为有一个菜鸟，我觉得默认主题已经很漂亮啦:)</p>

<p>我之前做项目接触了github，然后搜教程的时候突然发现可以用它写博客，所以一时好奇才写的。希望能记录下平时看到或者学到的东西，虽然水平有限，不值一哂，但对我自己来说毕竟是花过力气的东西，还是留些痕迹做纪念吧，也省得经常觉得自己很颓废</p>

<p>最近会整理一些以前的文档，用【旧】标注的文章可能会有些过时。我其实是个好奇心甚重的人，但是有点浅尝辄止的毛病，所以可以预感到我的“helloworld”分类下会有很多乱七八糟的东西……</p>

<h3>希望我能坚持下去</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『旧』 hello android 1.0：Linux下开发环境搭建]]></title>
    <link href="http://ziwu1216.github.com/blog/2012/11/26/old-hello-android-1-dot-0/"/>
    <updated>2012-11-26T23:32:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2012/11/26/old-hello-android-1-dot-0</id>
    <content type="html"><![CDATA[<p>这是4月左右写的，软件的版本可能比较旧了，仅供参考</p>

<p>以下为搭建过程，包括文件下载、java安装、eclipse和ADT安装、SDK Manager配置等</p>

<!--more-->


<h2>需要准备的安装文件</h2>

<ul>
<li>android-sdk_r17-linux.tgz</li>
<li>ADT-17.0.0.zip</li>
<li>jdk-7u3-linux-i586.tar.gz</li>
<li>eclipse-jee-indigo-SR2-linux-gtk.tar.gz

<h3>下载地址</h3>

<p><a href="http://developer.android.com/sdk/index.html">http://developer.android.com/sdk/index.html</a></p></li>
</ul>


<p><a href="http://developer.android.com/sdk/eclipse-adt.html">http://developer.android.com/sdk/eclipse-adt.html</a></p>

<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p>

<p><a href="http://www.eclipse.org/downloads/">http://www.eclipse.org/downloads/</a></p>

<p>将其拷贝到一个文件夹，以/home/android/为例</p>

<h2>Java环境安装配置</h2>

<h3>1.解压文件</h3>

<p>进入安装文件目录<code>cd /home/android/</code></p>

<p>在lib下创建目录用于安装<code>sudo mkdir /usr/lib/java</code></p>

<p>解压到目录下<code>sudo tar zxvf ./jdk-7u3-linux-i586.tar.gz -C /usr/lib/java/</code></p>

<h3>2.配置环境变量</h3>

<pre><code>sudo gedit /etc/bash.bashrc
</code></pre>

<p>在其中加入如下内容：</p>

<pre><code>export JAVA_HOME=/usr/lib/java/jdk1.7.0_03
export JRE_HOME=${JAVA_HOME}/jre
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
export PATH=${JAVA_HOME}/bin:$PATH
</code></pre>

<p>保存退出，重新开启终端</p>

<h3>3.验证是否安装成功</h3>

<p>执行命令</p>

<pre><code>java -version 
</code></pre>

<p>显示</p>

<pre><code>java version "1.7.0_03" 
Java(TM) SE Runtime Environment (build 1.7.0_03-b04) 
Java HotSpot(TM) Client VM (build 22.1-b02, mixed mode)
</code></pre>

<p>说明安装成功</p>

<h2>eclipse安装</h2>

<p>进入安装文件目录<code>cd /home/android/</code></p>

<p>解压文件<code>tar zxvf eclipse-jee-indigo-SR2-linux-gtk.tar.gz</code></p>

<p>进入解压后的eclipse目录，执行eclipse文件，即可启动eclipse</p>

<h2>android SDK安装</h2>

<h3>1.解压文件</h3>

<p>进入安装文件目录<code>cd /home/android/</code></p>

<p>解压文件<code>tar zxvf android-sdk_r17-linux.tgz</code></p>

<h3>2.安装ADT插件</h3>

<p>在线安装容易连接不上网站，所以选择离线安装</p>

<p>启动 Eclipse, 在菜单栏选择 Help > Install New Software&#8230;.</p>

<p>单击右上角的Add按钮，在弹出的对话框中，Name填写 &#8220;ADT&#8221;,单击Archive按钮，找到插件所在到包ADT-17.0.0.zip，点击OK</p>

<p><img src="http://ziwu1216.github.com/images/hello-android-1-0-add.png" title="add repository" alt="图片加载失败 :("></p>

<p>选择所有安装包，点击next根据提示进行安装，同意所有条款。把Contact all update sites during install to find required software 前面的复选框取消掉，否则下载会很慢</p>

<p><img src="http://ziwu1216.github.com/images/hello-android-1-0-adt-install.png" title="ADT install" alt="图片加载失败 :("></p>

<p>安装完重启eclipse，开头的对话框可以先取消，后续会安装</p>

<p>在eclipse中选择Window > Preferences..，在弹出的对话框中左边选择Android标签，右边SDK location选择Android SDK的目录，单击apply，再单击ok。在此过程中会弹出一个对话框问你是否要参加google的满意度调查报告，可以选择参加还是不参加，单击process按钮即可</p>

<p><img src="http://ziwu1216.github.com/images/hello-android-1-0-preferences.png" title="eclipse preferences" alt="图片加载失败 :("></p>

<h3>3.配置Android SDK Manager</h3>

<p>进入android sdk安装目录下的tools目录，运行Android SDK Manager</p>

<pre><code>cd /home/android/android-sdk-linux/tools/ 
./android 
</code></pre>

<p>在tools>options选中force https……http，等待列表刷新后，选中tools和想要版本的android平台，进行安装</p>

<p><img src="http://ziwu1216.github.com/images/hello-android-1-0-sdkManager-setting.png" title="SDK Manager setting" alt="图片加载失败 :(">
<img src="http://ziwu1216.github.com/images/hello-android-1-0-sdkManager.png" title="SDK Manager" alt="图片加载失败 :("></p>

<p>*不知道为什么，从eclipse启动SDK Manager时，tools选项里没有options……推荐从目录运行</p>

<p>*一些第三方插件如htc的工具等，需要注册，可以暂时不安装</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[hello android 1：Linux下开发环境搭建]]></title>
    <link href="http://ziwu1216.github.com/blog/2012/11/25/hello-android-1/"/>
    <updated>2012-11-25T14:46:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2012/11/25/hello-android-1</id>
    <content type="html"><![CDATA[<p>想试试android的游戏开发，但想换台笔记本做，于是翻出了之前自己写的环境搭建入门，居然已经是半年前了……我果然没什么坚持能力……去android开发官网看了下，google在API Level 17下提供了新的ADT Bundle，集成了Eclipse和ADT plugin，意味着环境搭建被大大简化，再也不用卡在ADT安装的各种网络连接问题上了:)</p>

<p>于是新开了一个ubuntu12.04虚拟机，重新搭建了一次开发环境。根据官网所说，如果已经有eclipse或者其他IDE，可以继续使用单独的SDK安装。半年前的搭建入门在<a href="http://ziwu1216.github.com/blog/2012/11/26/old-hello-android-1-dot-0/">这里</a>,供参考</p>

<p>以下为使用ADT Bundle的具体环境搭建过程</p>

<!--more-->


<h2>需要准备的安装文件</h2>

<ul>
<li><p>adt-bundle-linux-x86.zip</p>

<p>  ADT Bundle 包括了开发环境所需的绝大多数内容</p>

<ul>
<li>Eclipse + ADT plugin</li>
<li>Android SDK Tools</li>
<li>Android Platform-tools</li>
<li>The latest Android platform</li>
<li>The latest Android system image for the emulator</li>
</ul>
</li>
<li><p>jdk-7u9-linux-i586.tar.gz</p></li>
</ul>


<p>将所有安装文件放入一个文件夹，例如~/android</p>

<h3>下载地址</h3>

<p><a href="http://developer.android.com/sdk/index.html">下载adt bundle</a></p>

<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">下载jdk</a></p>

<h2>Java环境安装配置</h2>

<h3>1.解压文件</h3>

<p>进入安装文件目录<code>cd ~/android/</code></p>

<p>在lib下创建目录用于安装<code>sudo mkdir /usr/lib/java</code></p>

<p>解压到目录下<code>sudo tar zxvf ./jdk-7u9-linux-i586.tar.gz -C /usr/lib/java/</code></p>

<h3>2.配置环境变量</h3>

<pre><code>sudo gedit /etc/profile
</code></pre>

<p>在其中加入如下内容：</p>

<pre><code>export JAVA_HOME=/usr/lib/java/jdk1.7.0_09
export JRE_HOME=${JAVA_HOME}/jre
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
export PATH=${JAVA_HOME}/bin:$PATH
</code></pre>

<p>保存退出，重启ubuntu</p>

<h3>3.验证是否安装成功</h3>

<p>执行命令<code>java -version</code></p>

<p>显示</p>

<pre><code>java version "1.7.0_09"
</code></pre>

<p>说明安装成功</p>

<h2>Android Adt Bundle安装</h2>

<h3>1.解压文件</h3>

<p>进入安装文件目录<code>cd ~/android/</code></p>

<p>解压<code>unzip ./adt-bundle-linux-x86.zip</code></p>

<h3>2.首次启动</h3>

<p>进入解压后的adt-bundle-linux-x86/eclipse目录，执行eclipse文件，即可启动eclipse。第一次启动可以选择workspace和是否参加google信息收集</p>

<h2>Android SDK Manager配置</h2>

<p>Adt Bundle自带了最新版本的android平台，要开发其他平台的android程序或其他工具包，可以在SDK Manager中安装</p>

<p>进入android sdk安装目录下的tools目录，运行Android SDK Manager</p>

<pre><code>cd ~/android/adt-bundle-linux-x86/sdk/tools/
./android
</code></pre>

<p>选中所需的平台进行安装，我安装了2.3.3，这是我手机的android版本</p>

<p><img src="http://ziwu1216.github.com/images/hello-android-1-sdkManager.png" title="sdkManager" alt="图片加载失败 :("></p>

<p>在tools>options中，可以根据网络情况设置代理或选中<br/>
force https://&#8230; sources to be fetched using http://&#8230;</p>

<p>google要求必须安装的包是</p>

<ul>
<li>SDK Tools</li>
<li>SDK Platform-tools</li>
<li>SDK Platform（至少一个版本）</li>
</ul>


<p>推荐安装的包是</p>

<ul>
<li>System Image（便于使用android模拟器）</li>
<li>Android Support</li>
<li>SDK Samples</li>
</ul>

]]></content>
  </entry>
  
</feed>
