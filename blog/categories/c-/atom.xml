<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c++ | Jean's Blog]]></title>
  <link href="http://ziwu1216.github.com/blog/categories/c-/atom.xml" rel="self"/>
  <link href="http://ziwu1216.github.com/"/>
  <updated>2013-05-25T20:47:24+08:00</updated>
  <id>http://ziwu1216.github.com/</id>
  <author>
    <name><![CDATA[Jean]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[『转载整理』C++关键字]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/05/25/keywords-in-c-plus-plus/"/>
    <updated>2013-05-25T20:30:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/05/25/keywords-in-c-plus-plus</id>
    <content type="html"><![CDATA[<p>extern,const,static</p>

<!--more-->


<h2>编译单元(模块)</h2>

<p>当在VC这样的开发工具上编写完代码，点击编译按钮准备生成exe文件时，VC其实做了两步工作</p>

<ul>
<li>第一步，将每个.cpp(.c)和相应.h文件编译成obj文件.</li>
<li>第二步，将工程中所有的obj文件进行LINK生成最终的.exe文件.</li>
</ul>


<p>那么错误就有可能在两个地方产生，一个是编译时的错误，这个主要是语法错误，另一个是连接错误，主要是重复定义变量等。</p>

<p>我们所说的编译单元就是指在编译阶段生成的每个obj文件，一个obj文件就是一个编译单元，也就是说一个cpp(.c)和它相应的.h文件共同组成了一个编译单元，一个工程由很多个编译单元组成，每个obj文件里包含了变量存储的相对地址等 。</p>

<h2>extern</h2>

<h3>修饰变量或函数</h3>

<p><a href="http://ziwu1216.github.io/blog/2013/05/24/c-plus-plus-primer-notes-2/">前面文章</a>提过了，通常，在模块的头文件中,对本模块提供给其它模块引用的函数和全局变量以关键字extern声明</p>

<p>被extern修饰的变量（外部变量）是静态分配空间的，即程序开始时分配，结束时释放。</p>

<h3>extern C</h3>

<p><code>void foo( int x, int y );</code>函数被C编译器编译后在符号库中的名字为<code>_foo</code>，而C++编译器则会产生像<code>_foo_int_int</code>之类的名字</p>

<p><code>extern C</code>告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的</p>

<p>目的：实现C++与C及其它语言的混合编程</p>

<ul>
<li>在C++中引用C语言中的函数和变量
```c
/<em> c语言头文件：cExample.h </em>/

<h1>ifndef C_EXAMPLE_H</h1>

<h1>define C_EXAMPLE_H</h1>

extern int add(int x,int y);

<h1>endif</h1></li>
</ul>


<p>/<em> c语言实现文件：cExample.c </em>/</p>

<h1>include "cExample.h"</h1>

<p>int add( int x, int y )
{
  return x + y;
}</p>

<p>// c++实现文件，调用add：cppFile.cpp
extern "C"
{
  #include "cExample.h"
}
int main(int argc, char* argv[])
{
  add(2,3);
  return 0;
}
```</p>

<ul>
<li>在C中引用C++语言中的函数和变量
```c
//C++头文件 cppExample.h

<h1>ifndef CPP_EXAMPLE_H</h1>

<h1>define CPP_EXAMPLE_H</h1>

extern "C" int add( int x, int y );

<h1>endif</h1></li>
</ul>


<p>//C++实现文件 cppExample.cpp
＃include "cppExample.h"
int add( int x, int y )
{
  return x + y;
}</p>

<p>/<em> C实现文件 cFile.c
/</em> 这样会编译出错：＃include "cExample.h" <em>/
extern int add( int x, int y );
int main( int argc, char</em> argv[] )
{
  add( 2, 3 );
  return 0;
}
```</p>

<ul>
<li>常见头文件用法
```c

<h1>ifdef __cplusplus</h1>

extern "C" {

<h1>endif</h1>

/<em>...</em>/

<h1>ifdef __cplusplus</h1>

}

<h1>endif</h1>

<p>```</p></li>
</ul>


<h2>const</h2>

<p>```c
const int r=100;//标准const变量声明加初始化，编译器经过类型检查后直接用100在编译时替换。
//比#define的好处在于有类型检查</p>

<p>char <em>const cp; //到char的const指针
char const </em>pc1; //到const char的指针
const char *pc2; //到const char的指针（后两个声明是等同的）</p>

<p>//类的const对象只能访问const成员函数，而非const对象可以访问任意的成员函数，包括const成员函数；
```</p>

<h2>static</h2>

<h3>static 局部变量</h3>

<p>生存期为这个源程序, 不过作用域仍是局部，例如函数内部的static变量</p>

<h3>static 全局变量</h3>

<p>全局变量本身就是静态存储方式, 再加上static, 是改变他的作用域, 即只能本当前文件访问</p>

<ul>
<li>extern和static不能同时修饰一个变量</li>
<li>当你在头文件中使用static声明了全局变量后，它也同时被定义了（默认初始化为0）</li>
<li>一般定义static全局变量时，都把它放在原文件中而不是头文件，这样就不会给其他模块造成不必要的信息污染</li>
</ul>


<h3>static 函数</h3>

<p>函数的默认作用域是全局可见的, 即整个源程序, 如果在函数前加上static, 表示将其作用域缩小至本文件.</p>

<h3>static成员</h3>

<p>一个static成员只有唯一的一份副本，而不像常规的非static成员那样在每个对象里各有一份副本。</p>

<h3>static成员函数</h3>

<p>一个需要访问类成员，而不需要针对特定对象去调用的函数，也被称为一个static成员函数,它只能访问类的静态成员。</p>

<p>参考链接：<br/>
<a href="http://hi.baidu.com/zyxins/item/41666937440833493075a1e5">C/C++定义全局变量/常量几种方法的区别</a> <br/>
<a href="http://blog.csdn.net/citysheep/article/details/3923073">C++中extern “C”含义深层探索</a> <br/>
<a href="http://hi.baidu.com/laodun/item/8dcebde3d4710fadcf2d4fc7">关于const,static,extern,volatile的用法</a><br/>
<a href="http://www.cnblogs.com/fxjwind/archive/2011/07/05/2098631.html">C语言易混淆关键词详解-const, static, extern, typedef, 声明</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『转载整理』new和malloc的区别]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/05/25/new-vs-malloc/"/>
    <updated>2013-05-25T17:25:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/05/25/new-vs-malloc</id>
    <content type="html"><![CDATA[<p>new可以认为是malloc加构造函数的执行</p>

<!--more-->


<p>主要区别列表如下：</p>

<table>
<thead>
<tr>
<th>new     </th>
<th>   malloc</th>
</tr>
</thead>
<tbody>
<tr>
<td>建立对象    </td>
<td>   分配内存</td>
</tr>
<tr>
<td>c或c++     </td>
<td>   c</td>
</tr>
<tr>
<td>运算符       </td>
<td>   标准库函数</td>
</tr>
<tr>
<td>保留字,不需要头文件支持      </td>
<td>   需要头文件库函数支持</td>
</tr>
<tr>
<td>分配内存+调用类的构造函数   </td>
<td>   只分配内存，不会进行初始化</td>
</tr>
<tr>
<td>自动计算需要分配的空间       </td>
<td>   手动传递字节数</td>
</tr>
<tr>
<td>返回某种数据类型指针      </td>
<td>   返回void指针</td>
</tr>
</tbody>
</table>


<p>参考链接：<br/>
<a href="http://wmnmtm.blog.163.com/blog/static/38245714201203313587/">new与malloc</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Primer 读书笔记 2]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/05/24/c-plus-plus-primer-notes-2/"/>
    <updated>2013-05-24T00:01:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/05/24/c-plus-plus-primer-notes-2</id>
    <content type="html"><![CDATA[<p>有些细节的地方综合网络作了补充</p>

<!--more-->


<h2>第二章</h2>

<h3>2.1</h3>

<p>8bits - byte，4bytes - word</p>

<table>
<thead>
<tr>
<th align="left"> </th>
<th align="center"> 基本内置类型 </th>
<th align="left"> </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">char: </td>
<td align="center"> 1byte   </td>
<td align="left"> 基本字符集<br>char/unsigned char/signed char<br>(使用unsigned或signed来表示char，由编译器决定)</td>
</tr>
<tr>
<td align="left">wchar_t：</td>
<td align="center"> 2 or 4bytes </td>
<td align="left"> 扩展字符集（汉字和日文）</td>
</tr>
<tr>
<td align="left">bool： </td>
<td align="center">   1byte</td>
<td></td>
</tr>
<tr>
<td align="left">   </td>
<td align="center">    </td>
<td align="left">    </td>
</tr>
<tr>
<td align="left">short int (short)： </td>
<td align="center">  2bytes </td>
<td align="left"> 半个word，short/unsigned short</td>
</tr>
<tr>
<td align="left">int: </td>
<td align="center">  4bytes </td>
<td align="left">    一个word，int/unsigned</td>
</tr>
<tr>
<td align="left">long int (long)： </td>
<td align="center">    4bytes </td>
<td align="left">    long/unsigned long</td>
</tr>
<tr>
<td align="left">long long int:  </td>
<td align="center"> 8bytes</td>
<td></td>
</tr>
<tr>
<td align="left">   </td>
<td align="center">    </td>
<td align="left">    </td>
</tr>
<tr>
<td align="left">float： </td>
<td align="center">  4bytes </td>
<td align="left">    ~7 digits</td>
</tr>
<tr>
<td align="left">double： </td>
<td align="center"> 8bytes </td>
<td align="left">    ~15 digits</td>
</tr>
<tr>
<td align="left">long double： </td>
<td align="center">    8bytes </td>
<td align="left">    ~15 digits</td>
</tr>
</tbody>
</table>


<ul>
<li>无符号，最高位和其它位一样，用来表示该数的大小。</li>
<li>有符号，最高位为符号位，1表示负值。</li>
</ul>


<p>正数按原码存放，负数按补码存放。补码就是符号位不变，其余位数取反加1（从最低位开始至找到的第一个1均不变，符号位不变）。-1，原码是10000001，补码应该是11111111</p>

<p>很多时候，把超过取值范围的值赋给unsigned和signed类型，编译器会取模后存储。</p>

<h3>2.2</h3>

<p>字面值常量literal constant。只有内置类型存在字面值。
<code>c
20;//十进制
024;//八进制以0开头
0x14;//十六进制以0X或0x开头
128u;//unsigned
1024UL or 1024Lu;//unsigned long
1L;//long
3.14159f;
.001f;
0.;
1E-3F;
L'a';//wchar_t
\0;//转义字符\可以将ASCII码转为字面值常量
L"a wide string literal";
</code></p>

<h3>2.3</h3>

<p>变量初始化：</p>

<p><code>c
int ival(1024);//直接初始化
int ival = 1024;//复制初始化
double salary = 9.9, wage(salary + 0.01);//用前一个变量初始化后一个变量
</code></p>

<p>定义未初始化的变量时：</p>

<ul>
<li>内置类型：函数体外定义的自动初始化为0，函数体内定义的不自动初始化</li>
<li>类类型：必须有默认构造函数才能自动初始化，否则无法定义没有初始值的变量</li>
</ul>


<p>变量的定义用于为变量分配存储空间，可以指定初始值。变量有且仅有一个定义。<br/>
变量的声明用于向程序表明变量的类型和名字，可以声明多次。定义也是声明。</p>

<p>```c
extern int i;//声明不定义，在file2，可以使用file1里的变量i(外部存储类型)
int i;//定义，在file1</p>

<p>extern double pi = 3.1416;//定义，因为有初始化，要分配空间
```</p>

<p>变量的作用域</p>

<ul>
<li>全局作用域：所有函数外部，在程序的任何地方访问</li>
<li>局部作用域：<code>{}</code>括起来的代码范围，例如函数内部</li>
<li>语句作用域：for等语句内，从它定义的位置开始，一直到for所带语句的作用域结束</li>
<li>类作用域：每个类的成员不同于任何其他类(任何其他作用域)的成员</li>
<li>命名空间作用域：namespace</li>
</ul>


<h3>2.4</h3>

<p>```c
const int bufSize = 512;//常量在定义时必须初始化</p>

<p>extern const int bufSize = fcn();//定义，在file1
//在全局作用域声明的const变量是定义该对象的文件的局部变量，不能被其他文件访问
//需要加extern，才能被其他文件访问
extern const int bufSize;//声明，在file2，可以使用file1里的变量
```</p>

<h3>2.5</h3>

<p>```c
int ival = 1024;
int &amp;refval = ival;//引用只是别名，引用不可能在初始化后绑定到其他对象
int &refVal2;//错误，引用必须初始化
int &amp;refVal3 = 10;//错误，引用必需使用同类型的对象初始化</p>

<p>const int i = 1024;
const int &amp;ref = i;//指向const对象的引用
const int &amp;r = 42;//正确，const引用可以绑定到右值</p>

<p>double dval = 3.14;
const int &amp;ri = dval;//正确，const引用可以绑定到不同但相关的类型
//编译器会做如下转换，如果允许非const引用，则对ri的修改只能修改temp，不能修改dval
//int temp = dval;
//const int &amp;ri = temp;
```</p>

<h3>2.6</h3>

<p>typedef可以用来定义类型的同义词
<code>c
typedef int exam_socre;
</code></p>

<h3>2.7</h3>

<p>枚举变量，默认第一个枚举成员赋值为0，后面比前面一个加1
<code>c
enum Points{point2d = 2, point2w, point3d = 3, point3w};
//point2d = 2, point2w = 3比前一个大1
//point3d = 3, 和point2w值重复了，是可以的
//point3w = 4
</code></p>

<h3>2.8</h3>

<p><code>class</code>在第一个访问标号前的任何成员都隐式指定为<code>private</code>，<code>struct</code>则指定为<code>public</code></p>

<h3>2.9</h3>

<p>编译和链接多个源文件
<code>
CC -c main.cc Sales_item.cc
</code>
或者
<code>
CC -c main.cc
CC -c Sales_item.cc
CC main.o Sales_item.o
</code></p>

<p>头文件中只能有声明，不能有定义。例外：</p>

<ul>
<li>定义类</li>
<li>定义值在编译时就已知的const对象<br/>
上文“const变量是定义该对象的文件的局部变量”就是为了允许这么做<br/>
实践中，大部分编译器会用相应的常量表达式来替换对这些const变量的使用，所以不会有存储空间存储这类const变量<br/>
不是编译时已知值的const对象不应该放在头文件</li>
<li>定义inline函数</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『转载整理』C/C++中内存机制]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/05/17/memory-in-c-and-c-plus-plus/"/>
    <updated>2013-05-17T00:15:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/05/17/memory-in-c-and-c-plus-plus</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>在多任务操作系统中的每一个进程都运行在一个属于它自己的内存沙盘中。这个沙盘就是虚拟地址空间（virtual address space），在32位模式下它总是一个<code>4GB</code>的内存地址块。这些虚拟地址通过页表（page table）映射到物理内存，页表由操作系统维护并被处理器引用。每一个进程拥有一套属于它自己的页表，只要虚拟地址被使能，那么它就会作用于这台机器上运行的所有软件，包括内核本身，因此一部分虚拟地址必须保留给内核使用</p>

<!--more-->


<p><img src="/images/memory-in-c-and-c-plus-plus-block.png" title="程序内存块" alt="图片加载失败 :("></p>

<p>在Linux中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。内核代码和数据总是可寻址的，随时准备处理中断和系统调用。与此相反，用户模式地址空间的映射随进程切换的发生而不断变化</p>

<p><img src="/images/memory-in-c-and-c-plus-plus-switch.png" title="程序切换" alt="图片加载失败 :("></p>

<p>下面是一个Linux进程的标准的内存段布局</p>

<p><img src="/images/memory-in-c-and-c-plus-plus-layout.png" title="内存布局" alt="图片加载失败 :("></p>

<ul>
<li>进程地址空间中最顶部的段是栈，大多数编程语言将之用于存储局部变量和函数参数。进程中的每一个线程都有属于自己的栈。</li>
<li>在栈的下方是内存映射段。此处，内核将文件的内容直接映射到内存。任何应用程序都可以通过Linux的mmap()或Windows的CreateFileMapping() / MapViewOfFile()请求这种映射。内存映射是一种方便高效的文件I/O方式，所以它被用于加载动态库。</li>
<li>堆用于运行时内存分配。但不同点是，堆用于存储那些生存期与函数调用无关的数据。在C语言中，堆分配的接口是malloc()系列函数，而在具有垃圾收集功能的语言（如C#）中，此接口是new关键字。</li>
<li>BSS（未初始化数据区）保存的是未被初始化的静态变量内容</li>
<li>数据段保存在源代码中已经初始化了的静态变量内容</li>
<li>代码段是只读的，保存了你全部的代码外加零零碎碎的东西，比如字符串字面值。</li>
</ul>


<p>下图展示了这些段以及我们例子中的变量
<img src="/images/memory-in-c-and-c-plus-plus-example.png" title="例子展示" alt="图片加载失败 :("></p>

<h2>C语言中的内存机制</h2>

<ul>
<li><p>栈(Stack)<br/>
位于函数内的局部变量（包括函数实参），由编译器负责分配释放，函数结束，栈变量失效。</p></li>
<li><p>堆(Heap）<br/>
由程序员用malloc/calloc/realloc分配，free释放。如果程序员忘记free了，则会造成内存泄露，程序结束时该片内存会由OS回收。</p></li>
<li><p>全局区/静态区(Global Static Area)<br/>
全局变量和静态变量存放区，程序一经编译好，该区域便存在。程序结束时释放。<br/>
在C语言中，初始化的全局变量和静态变量和未初始化的放在相邻的两个区域。</p></li>
<li><p>C风格字符串常量存储区<br/>
专门存放字符串常量的地方，程序结束时释放。（字符串常量一般放在 .text段 或单独的 .rodata段）【？？？似乎跟C++的常量存储区类似。const常量是否也放在这里？】</p></li>
<li><p>程序代码区</p></li>
</ul>


<h2>C++中的内存机制</h2>

<p>与C相同部分不再描述</p>

<ul>
<li><p>栈(Stack)</p></li>
<li><p>堆（Heap)<br/>
由new申请的内存，由delete或delete[]负责释放。</p></li>
<li><p>自由存储区(Free Storage)<br/>
malloc/calloc/realloc分配的内存。对象的生存周期可以比内存被分配的时间短，即可以用void*访问这块内存，而没有具体对象。自由存储区和堆的本质区别有争议，具体可见<a href="http://hi.baidu.com/yangdgjy/item/23a3c28daa7f495c840fabb2">这里</a></p></li>
<li><p>全局区/静态区(Global Static Area)<br/>
在C++中，由于全局变量和静态变量编译器会给这些变量自动初始化赋值，所以没有区分了初始化变量和未初始化变量了</p></li>
<li><p>常量存储区<br/>
存储字符串常量和其他在编译时已知的数据。整个程序运行期间可见。只读。</p></li>
<li><p>程序代码区</p></li>
</ul>


<hr />

<p>参考链接:</p>

<p><a href="http://blog.csdn.net/drshenlei/article/details/4339110">剖析程序的内存布局</a><br/>
<a href="http://www.cnblogs.com/ComputerG/archive/2012/02/01/2334898.html">c/c++内存机制（一）（原）</a><br/>
<a href="http://www.gotw.ca/gotw/009.htm">Memory Management - Part I</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构与算法分析 读书笔记 4]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/03/18/data-structures-notes-4/"/>
    <updated>2013-03-18T23:53:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/03/18/data-structures-notes-4</id>
    <content type="html"><![CDATA[<p>第三章剩下的部分</p>

<!--more-->


<h2>第三章 表、栈和队列</h2>

<h3>3.4 向量的实现</h3>

<p>vector是基本类类型，这意味着不同于基本数组，vector可以复制并且其占用的内存可以自动回收（通过析构函数）</p>

<p>【？？？】程序第37行，为什么<code>reserve()</code>函数中判断的是<code>newCapacity &lt; theSize</code>而不是<code>newCapacity &lt; theCapacity</code>？</p>

<h3>3.5 表的实现</h3>

<p>在表的前端和末尾添加额外结点作为标志，称为哨兵结点。头部结点称为表头结点，末端的结点称为尾结点。使用好处是可以去掉很多特例，简化程序代码。</p>

<p>List中的代码摘抄<br/>
``` c
class List
{
private:</p>

<pre><code>struct Node{...};
</code></pre>

<p>public:</p>

<pre><code>class const_iterator{...};
class iterator: public const_iterator{...};
...
</code></pre>

<p>private:</p>

<pre><code>int theSize;
Node *head;
Node *tail;
...
</code></pre>

<p>};
```</p>

<p>定义前缀和后缀<code>operator++</code>的区别方法：给前缀指定空参数表，给后缀指定一个匿名的int参数。实现指出在许多可以选择使用前缀或后缀的情况下，使用前缀形式要快于使用后缀形式<br/>
``` c
const_iterator operator++()
{</p>

<pre><code>current = current-&gt;next;
return *this;
</code></pre>

<p>}</p>

<p>const_iterator operator++(int)
{</p>

<pre><code>const_iterator old = *this;
++(*this);
return old;
</code></pre>

<p>}
```</p>

<h3>3.6 栈ADT</h3>

<p>栈的操作基本只有<code>push(),pop(),top()</code>，只有栈顶元素是可访问的。</p>

<p>栈是一个表，用数组和单向链表都可以实现，所以list和vector都支持栈，且操作为常量时间操作。</p>

<h4>栈的应用</h4>

<p>后缀或逆波兰记法：将<code>4.99*1.06 + 5.99 +6.99*1.06</code>（称为中缀式）记为<code>4.99 1.06 * 5.99 + 6.99 1.06 * +</code>。   当一个表达式以后缀记法给出时，没有必要知道任何优先规则。</p>

<p>可以用栈实现中缀式到后缀式的转换，主要原则是入栈操作符，读取新操作符时，从栈顶弹出直到遇到优先级更低的元素为止【需复习】</p>

<p>尾递归：在最后一行的递归调用，是极差的使用递归的例子。<br/>
通过将代码放到一个while循环中并用每个函数的一个参数代替递归调用，可以机械地消除尾递归。【？？？】不明白尾递归和其他递归的本质区别<br/>
递归总能够被彻底除去（编译器的工作），但提速的同时降低了程序的清晰性。</p>

<h3>3.7 队列ADT</h3>

<p>队列也是表。基本操作<code>enqueue(),dequeue()</code></p>

<p>循环数组：处理front或back到达数组尾端，而数组前面有很多空位的情况。</p>
]]></content>
  </entry>
  
</feed>
