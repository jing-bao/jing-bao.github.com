<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c++ | Jean's Blog]]></title>
  <link href="http://ziwu1216.github.com/blog/categories/c-/atom.xml" rel="self"/>
  <link href="http://ziwu1216.github.com/"/>
  <updated>2013-05-24T13:54:04+08:00</updated>
  <id>http://ziwu1216.github.com/</id>
  <author>
    <name><![CDATA[Jean]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++ Primer 读书笔记 2]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/05/24/c-plus-plus-primer-notes-2/"/>
    <updated>2013-05-24T00:01:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/05/24/c-plus-plus-primer-notes-2</id>
    <content type="html"><![CDATA[<p>有些细节的地方综合网络作了补充</p>

<!--more-->


<h2>第二章</h2>

<h3>2.1</h3>

<p>8bits - byte，4bytes - word</p>

<table>
<thead>
<tr>
<th align="left"> </th>
<th align="center"> 基本内置类型 </th>
<th align="left"> </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">char: </td>
<td align="center"> 1byte   </td>
<td align="left"> 基本字符集<br>char/unsigned char/signed char<br>(使用unsigned或signed来表示char，由编译器决定)</td>
</tr>
<tr>
<td align="left">wchar_t：</td>
<td align="center"> 2 or 4bytes </td>
<td align="left"> 扩展字符集（汉字和日文）</td>
</tr>
<tr>
<td align="left">bool： </td>
<td align="center">   1byte</td>
<td></td>
</tr>
<tr>
<td align="left">   </td>
<td align="center">    </td>
<td align="left">    </td>
</tr>
<tr>
<td align="left">short int (short)： </td>
<td align="center">  2bytes </td>
<td align="left"> 半个word，short/unsigned short</td>
</tr>
<tr>
<td align="left">int: </td>
<td align="center">  4bytes </td>
<td align="left">    一个word，int/unsigned</td>
</tr>
<tr>
<td align="left">long int (long)： </td>
<td align="center">    4bytes </td>
<td align="left">    long/unsigned long</td>
</tr>
<tr>
<td align="left">long long int:  </td>
<td align="center"> 8bytes</td>
<td></td>
</tr>
<tr>
<td align="left">   </td>
<td align="center">    </td>
<td align="left">    </td>
</tr>
<tr>
<td align="left">float： </td>
<td align="center">  4bytes </td>
<td align="left">    ~7 digits</td>
</tr>
<tr>
<td align="left">double： </td>
<td align="center"> 8bytes </td>
<td align="left">    ~15 digits</td>
</tr>
<tr>
<td align="left">long double： </td>
<td align="center">    8bytes </td>
<td align="left">    ~15 digits</td>
</tr>
</tbody>
</table>


<ul>
<li>无符号，最高位和其它位一样，用来表示该数的大小。</li>
<li>有符号，最高位为符号位，1表示负值。</li>
</ul>


<p>正数按原码存放，负数按补码存放。补码就是符号位不变，其余位数取反加1（从最低位开始至找到的第一个1均不变，符号位不变）。-1，原码是10000001，补码应该是11111111</p>

<p>很多时候，把超过取值范围的值赋给unsigned和signed类型，编译器会取模后存储。</p>

<h3>2.2</h3>

<p>字面值常量literal constant。只有内置类型存在字面值。
<code>c
20;//十进制
024;//八进制以0开头
0x14;//十六进制以0X或0x开头
128u;//unsigned
1024UL or 1024Lu;//unsigned long
1L;//long
3.14159f;
.001f;
0.;
1E-3F;
L'a';//wchar_t
\0;//转义字符\可以将ASCII码转为字面值常量
L"a wide string literal";
</code></p>

<h3>2.3</h3>

<p>变量初始化：</p>

<p><code>c
int ival(1024);//直接初始化
int ival = 1024;//复制初始化
double salary = 9.9, wage(salary + 0.01);//用前一个变量初始化后一个变量
</code></p>

<p>定义未初始化的变量时：</p>

<ul>
<li>内置类型：函数体外定义的自动初始化为0，函数体内定义的不自动初始化</li>
<li>类类型：必须有默认构造函数才能自动初始化，否则无法定义没有初始值的变量</li>
</ul>


<p>变量的定义用于为变量分配存储空间，可以指定初始值。变量有且仅有一个定义。<br/>
变量的声明用于向程序表明变量的类型和名字，可以声明多次。定义也是声明。</p>

<p>```c
extern int i;//声明不定义，在file2，可以使用file1里的变量i(外部存储类型)
int i;//定义，在file1</p>

<p>extern double pi = 3.1416;//定义，因为有初始化，要分配空间
```</p>

<p>变量的作用域</p>

<ul>
<li>全局作用域：所有函数外部，在程序的任何地方访问</li>
<li>局部作用域：<code>{}</code>括起来的代码范围，例如函数内部</li>
<li>语句作用域：for等语句内，从它定义的位置开始，一直到for所带语句的作用域结束</li>
<li>类作用域：每个类的成员不同于任何其他类(任何其他作用域)的成员</li>
<li>命名空间作用域：namespace</li>
</ul>


<h3>2.4</h3>

<p>```c
const int bufSize = 512;//常量在定义时必须初始化</p>

<p>extern const int bufSize = fcn();//定义，在file1
//在全局作用域声明的const变量是定义该对象的文件的局部变量，不能被其他文件访问
//需要加extern，才能被其他文件访问
extern const int bufSize;//声明，在file2，可以使用file1里的变量
```</p>

<h3>2.5</h3>

<p>```c
int ival = 1024;
int &amp;refval = ival;//引用只是别名，引用不可能在初始化后绑定到其他对象
int &refVal2;//错误，引用必须初始化
int &amp;refVal3 = 10;//错误，引用必需使用同类型的对象初始化</p>

<p>const int i = 1024;
const int &amp;ref = i;//指向const对象的引用
const int &amp;r = 42;//正确，const引用可以绑定到右值</p>

<p>double dval = 3.14;
const int &amp;ri = dval;//正确，const引用可以绑定到不同但相关的类型
//编译器会做如下转换，如果允许非const引用，则对ri的修改只能修改temp，不能修改dval
//int temp = dval;
//const int &amp;ri = temp;
```</p>

<h3>2.6</h3>

<p>typedef可以用来定义类型的同义词
<code>c
typedef int exam_socre;
</code></p>

<h3>2.7</h3>

<p>枚举变量，默认第一个枚举成员赋值为0，后面比前面一个加1
<code>c
enum Points{point2d = 2, point2w, point3d = 3, point3w};
//point2d = 2, point2w = 3比前一个大1
//point3d = 3, 和point2w值重复了，是可以的
//point3w = 4
</code></p>

<h3>2.8</h3>

<p><code>class</code>在第一个访问标号前的任何成员都隐式指定为<code>private</code>，<code>struct</code>则指定为<code>public</code></p>

<h3>2.9</h3>

<p>编译和链接多个源文件
<code>
CC -c main.cc Sales_item.cc
</code>
或者
<code>
CC -c main.cc
CC -c Sales_item.cc
CC main.o Sales_item.o
</code></p>

<p>头文件中只能有声明，不能有定义。例外：</p>

<ul>
<li>定义类</li>
<li>定义值在编译时就已知的const对象<br/>
上文“const变量是定义该对象的文件的局部变量”就是为了允许这么做<br/>
实践中，大部分编译器会用相应的常量表达式来替换对这些const变量的使用，所以不会有存储空间存储这类const变量<br/>
不是编译时已知值的const对象不应该放在头文件</li>
<li>定义inline函数</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[『转载整理』C/C++中内存机制]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/05/17/memory-in-c-and-c-plus-plus/"/>
    <updated>2013-05-17T00:15:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/05/17/memory-in-c-and-c-plus-plus</id>
    <content type="html"><![CDATA[<h2>概述</h2>

<p>在多任务操作系统中的每一个进程都运行在一个属于它自己的内存沙盘中。这个沙盘就是虚拟地址空间（virtual address space），在32位模式下它总是一个<code>4GB</code>的内存地址块。这些虚拟地址通过页表（page table）映射到物理内存，页表由操作系统维护并被处理器引用。每一个进程拥有一套属于它自己的页表，只要虚拟地址被使能，那么它就会作用于这台机器上运行的所有软件，包括内核本身，因此一部分虚拟地址必须保留给内核使用</p>

<!--more-->


<p><img src="/images/memory-in-c-and-c-plus-plus-block.png" title="程序内存块" alt="图片加载失败 :("></p>

<p>在Linux中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。内核代码和数据总是可寻址的，随时准备处理中断和系统调用。与此相反，用户模式地址空间的映射随进程切换的发生而不断变化</p>

<p><img src="/images/memory-in-c-and-c-plus-plus-switch.png" title="程序切换" alt="图片加载失败 :("></p>

<p>下面是一个Linux进程的标准的内存段布局</p>

<p><img src="/images/memory-in-c-and-c-plus-plus-layout.png" title="内存布局" alt="图片加载失败 :("></p>

<ul>
<li>进程地址空间中最顶部的段是栈，大多数编程语言将之用于存储局部变量和函数参数。进程中的每一个线程都有属于自己的栈。</li>
<li>在栈的下方是内存映射段。此处，内核将文件的内容直接映射到内存。任何应用程序都可以通过Linux的mmap()或Windows的CreateFileMapping() / MapViewOfFile()请求这种映射。内存映射是一种方便高效的文件I/O方式，所以它被用于加载动态库。</li>
<li>堆用于运行时内存分配。但不同点是，堆用于存储那些生存期与函数调用无关的数据。在C语言中，堆分配的接口是malloc()系列函数，而在具有垃圾收集功能的语言（如C#）中，此接口是new关键字。</li>
<li>BSS（未初始化数据区）保存的是未被初始化的静态变量内容</li>
<li>数据段保存在源代码中已经初始化了的静态变量内容</li>
<li>代码段是只读的，保存了你全部的代码外加零零碎碎的东西，比如字符串字面值。</li>
</ul>


<p>下图展示了这些段以及我们例子中的变量
<img src="/images/memory-in-c-and-c-plus-plus-example.png" title="例子展示" alt="图片加载失败 :("></p>

<h2>C语言中的内存机制</h2>

<ul>
<li><p>栈(Stack)<br/>
位于函数内的局部变量（包括函数实参），由编译器负责分配释放，函数结束，栈变量失效。</p></li>
<li><p>堆(Heap）<br/>
由程序员用malloc/calloc/realloc分配，free释放。如果程序员忘记free了，则会造成内存泄露，程序结束时该片内存会由OS回收。</p></li>
<li><p>全局区/静态区(Global Static Area)<br/>
全局变量和静态变量存放区，程序一经编译好，该区域便存在。程序结束时释放。<br/>
在C语言中，初始化的全局变量和静态变量和未初始化的放在相邻的两个区域。</p></li>
<li><p>C风格字符串常量存储区<br/>
专门存放字符串常量的地方，程序结束时释放。（字符串常量一般放在 .text段 或单独的 .rodata段）【？？？似乎跟C++的常量存储区类似。const常量是否也放在这里？】</p></li>
<li><p>程序代码区</p></li>
</ul>


<h2>C++中的内存机制</h2>

<p>与C相同部分不再描述</p>

<ul>
<li><p>栈(Stack)</p></li>
<li><p>堆（Heap)<br/>
由new申请的内存，由delete或delete[]负责释放。</p></li>
<li><p>自由存储区(Free Storage)<br/>
malloc/calloc/realloc分配的内存。对象的生存周期可以比内存被分配的时间短，即可以用void*访问这块内存，而没有具体对象。自由存储区和堆的本质区别有争议，具体可见<a href="http://hi.baidu.com/yangdgjy/item/23a3c28daa7f495c840fabb2">这里</a></p></li>
<li><p>全局区/静态区(Global Static Area)<br/>
在C++中，由于全局变量和静态变量编译器会给这些变量自动初始化赋值，所以没有区分了初始化变量和未初始化变量了</p></li>
<li><p>常量存储区<br/>
存储字符串常量和其他在编译时已知的数据。整个程序运行期间可见。只读。</p></li>
<li><p>程序代码区</p></li>
</ul>


<hr />

<p>参考链接:</p>

<p><a href="http://blog.csdn.net/drshenlei/article/details/4339110">剖析程序的内存布局</a><br/>
<a href="http://www.cnblogs.com/ComputerG/archive/2012/02/01/2334898.html">c/c++内存机制（一）（原）</a><br/>
<a href="http://www.gotw.ca/gotw/009.htm">Memory Management - Part I</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构与算法分析 读书笔记 4]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/03/18/data-structures-notes-4/"/>
    <updated>2013-03-18T23:53:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/03/18/data-structures-notes-4</id>
    <content type="html"><![CDATA[<p>第三章剩下的部分</p>

<!--more-->


<h2>第三章 表、栈和队列</h2>

<h3>3.4 向量的实现</h3>

<p>vector是基本类类型，这意味着不同于基本数组，vector可以复制并且其占用的内存可以自动回收（通过析构函数）</p>

<p>【？？？】程序第37行，为什么<code>reserve()</code>函数中判断的是<code>newCapacity &lt; theSize</code>而不是<code>newCapacity &lt; theCapacity</code>？</p>

<h3>3.5 表的实现</h3>

<p>在表的前端和末尾添加额外结点作为标志，称为哨兵结点。头部结点称为表头结点，末端的结点称为尾结点。使用好处是可以去掉很多特例，简化程序代码。</p>

<p>List中的代码摘抄<br/>
``` c
class List
{
private:</p>

<pre><code>struct Node{...};
</code></pre>

<p>public:</p>

<pre><code>class const_iterator{...};
class iterator: public const_iterator{...};
...
</code></pre>

<p>private:</p>

<pre><code>int theSize;
Node *head;
Node *tail;
...
</code></pre>

<p>};
```</p>

<p>定义前缀和后缀<code>operator++</code>的区别方法：给前缀指定空参数表，给后缀指定一个匿名的int参数。实现指出在许多可以选择使用前缀或后缀的情况下，使用前缀形式要快于使用后缀形式<br/>
``` c
const_iterator operator++()
{</p>

<pre><code>current = current-&gt;next;
return *this;
</code></pre>

<p>}</p>

<p>const_iterator operator++(int)
{</p>

<pre><code>const_iterator old = *this;
++(*this);
return old;
</code></pre>

<p>}
```</p>

<h3>3.6 栈ADT</h3>

<p>栈的操作基本只有<code>push(),pop(),top()</code>，只有栈顶元素是可访问的。</p>

<p>栈是一个表，用数组和单向链表都可以实现，所以list和vector都支持栈，且操作为常量时间操作。</p>

<h4>栈的应用</h4>

<p>后缀或逆波兰记法：将<code>4.99*1.06 + 5.99 +6.99*1.06</code>（称为中缀式）记为<code>4.99 1.06 * 5.99 + 6.99 1.06 * +</code>。   当一个表达式以后缀记法给出时，没有必要知道任何优先规则。</p>

<p>可以用栈实现中缀式到后缀式的转换，主要原则是入栈操作符，读取新操作符时，从栈顶弹出直到遇到优先级更低的元素为止【需复习】</p>

<p>尾递归：在最后一行的递归调用，是极差的使用递归的例子。<br/>
通过将代码放到一个while循环中并用每个函数的一个参数代替递归调用，可以机械地消除尾递归。【？？？】不明白尾递归和其他递归的本质区别<br/>
递归总能够被彻底除去（编译器的工作），但提速的同时降低了程序的清晰性。</p>

<h3>3.7 队列ADT</h3>

<p>队列也是表。基本操作<code>enqueue(),dequeue()</code></p>

<p>循环数组：处理front或back到达数组尾端，而数组前面有很多空位的情况。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构与算法分析 读书笔记 3]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/03/14/data-structures-notes-3/"/>
    <updated>2013-03-14T23:58:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/03/14/data-structures-notes-3</id>
    <content type="html"><![CDATA[<p>3.1到3.3节。重点记录的是vector和list的操作函数，因为以前用的比较少</p>

<!--more-->


<h2>第三章 表、栈和队列</h2>

<h3>3.1 抽象数据类型ADT</h3>

<p>抽象数据类型（ADT）是带有一组操作的一些对象的集合。在ADT的定义中根本没有提到这组操作是如何实现的</p>

<h3>3.2 表ADT</h3>

<ul>
<li>简单数组实现：适合在末尾插入元素，之后只有数组访问<br/>
数组是静态分配的，但vector类允许在需要的时候将数组的大小增加一倍</li>
<li>链表实现：适合插入和删除在整个表中都发生<br/>
典型的链表保持至表的两端的链接，为了第一项的添加删除和末尾的新项添加为常量时间【应该是由于在两端操作数据最为常见】<br/>
双向链表，可以方便删除最后一项(方便找到倒数第二项)</li>
</ul>


<h3>3.3 STL中的向量和表</h3>

<p>标准模板库STL实现了公共数据结构，例如表ADT。这些数据结构称为集合（collection）或容器（container）</p>

<ul>
<li>vector给出了表ADT的可增长的数组实现。<br/>
优点：常量时间内可索引【findKth】，缺点：插入或删除代价昂贵（除非发生在末尾），查找效率低【find】</li>
<li>list提供表ADT的双向链表实现。<br/>
优点：插入和删除代价小，缺点：不容易索引，查找效率低</li>
</ul>


<p>常用方法：<br/>
``` c
int size() const;
void clear();//删除容器内的所有元素
bool empty();
//以下四个都为常量时间
void push_back(const Object &amp; x);//在表的末尾添加x
void pop_back();//删除表的末尾对象
const Object &amp; back() const;
const Object &amp; front() const;</p>

<p>//仅针对list
void push_front(const Object &amp; x);
void pop_front();</p>

<p>//仅针对vector
Object &amp; operator<a href="int%20idx"></a>;//不包含边界检测
Object &amp; at(int idx);//包含边界检测
int capacity() const;//返回vector的内部容量
void reserve(int new Capacity);//设定vector的新容量
```</p>

<h4>迭代器iterator</h4>

<p>通过内置类型iterator来标记位置，例如<code>list&lt;string&gt;::iterator</code>和<code>vector&lt;int&gt;::iterator</code></p>

<p>相关方法：<br/>
<code>c
iterator begin();//返回指向容器第一项的适当迭代器
iterator end();//指向容器的终止标志，容器中最后一项的后面的位置，边界之外
itr++; ++itr;
*itr;//返回itr指定位置的对象的引用
itr1 == itr2; itr1 != itr2;//是否指向同一个位置
iterator insert(iterator pos, const Object &amp; x);//返回插入项位置。对list常量时间，对vector不是
iterator erase(iterator pos);//返回pos下一个元素的位置，操作完成后pos失效
iterator erase(iterator start, iterator end);//删除的元素直到但不包括end
</code>
【注意错误】我写的对表使用erase的代码
``` c WRONG!!!
//1.erase后itr失效，不能继续使用了
//2.使用itr+2操作会超过lst.end()，越界
//...是否还有其他错误？</p>

<p>template <typename Container>
void removeEveryOtherItem(Container &amp; lst)
{</p>

<pre><code>for(Container::iterator itr = lst.begin(); itr != lst.end(); itr=itr+2)
    lst.erase(itr);
</code></pre>

<p>}
```</p>

<p>STL也包含const_iterator，*const_iterator会返回常量引用，不能成为左值</p>

<p><code>c
iterator begin()
const_iterator begin() const
</code></p>

<p>两个版本的begin可以在同一个类里，因为方法的定常性被认为是标号的一部分
如果对非常量容器调用begin，返回iterator的版本被调用。如果对常量容器调用，返回const_iterator</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构与算法分析 读书笔记 2]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/03/10/data-structures-notes-2/"/>
    <updated>2013-03-10T22:39:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/03/10/data-structures-notes-2</id>
    <content type="html"><![CDATA[<p>半个多月前就记了，一直都没整理……第二章</p>

<!--more-->


<h2>第二章 算法分析</h2>

<p>算法是为求解一个问题需要遵循的、被清楚地指定的简单指令的集合。</p>

<h3>2.1 数学基础</h3>

<p><img src="/images/data-structures-notes-2-def.PNG" title="定义" alt="图片加载失败 :(">
这些定义是相对增长率的比较。</p>

<ul>
<li>大O，f是T的上界</li>
<li>omega，g是T的下界</li>
<li>theta，表示严格的增长率相等。<br/>
【？？？】【为什么定义四是对所有常数？】</li>
</ul>


<p>重要法则：<img src="/images/data-structures-notes-2-rule.PNG" title="法则" alt="图片加载失败 :("><br/>
典型增长率：<img src="/images/data-structures-notes-2-rate.PNG" title="典型增长率" alt="图片加载失败 :("></p>

<p>不要将常数或低阶项放进大O</p>

<p>可以通过计算lim（N→+∞）f(N)/g(N)来比较函数的相对增长率（洛必达法则，分子分母求导）</p>

<h3>2.3 要分析的问题</h3>

<p>分析程序的运行时间，一般需要最坏情况而非平均情况，一是因为对所有输入提供界限，二是因为平均计算起来困难。</p>

<p>高效算法中，数据读入常常成为瓶颈。</p>

<h3>2.4 运行时间计算</h3>

<p>一般法则</p>

<ul>
<li>法则1： for循环，时间至多是该循环内语句（包括测试）的运行时间乘以迭代的次数</li>
<li>法则2： 嵌套循环，从里向外分析【也是分析运行时间的基本策略】，一组嵌套循环内部的一条语句总的运行时间，为该语句时间乘以该组所有循环的大小的乘积</li>
<li>法则3： 顺序语句，将各个语句的运行时间求和</li>
<li>法则4： if/else语句，不超过判断语句时间加分支中运行较长的时间之和</li>
</ul>


<p>递归和调用的运行时间分析举例【！！！需复习】<br/>
令T(N)为求解大小为N的问题所花费时间，基准条件得到T(0)，T(1)等，迭代得到关系式如T(N) = 2T(N/2) + O(N),求解。【？？？】【如何求解】</p>

<h4>最大子序列和问题的求解</h4>

<p>多重求和公式计算算法复杂度【！！！需复习】</p>

<p>递归算法，“分治”策略，把整组数据分为左右两个子序列，考虑可能出现在左边，右边，或横跨左右。【！！！需编码】  <br/>
递归函数调用的一般形式是传递输入数组以及左边界和右边界，它们界定了数组要被处理的部分。<br/>
【在递归中，设计传递参数很重要，书中的例子避免了子序列的拷贝，比我开始设计的参数好很多】</p>

<p>联机算法：在任意时刻，算法都能对它已经读入的数据给出问题的正确答案。仅需要常量空间并以线性时间运行的算法几乎是完美的算法。</p>

<h4>O(logN)</h4>

<p>如果一个算法用常数时间将问题的大小削减为其一部分（通常是1/2），那么该算法就是O(logN)的。</p>

<ul>
<li>二分搜索</li>
<li>欧几里得算法</li>
<li>幂运算</li>
</ul>


<h4>检验分析</h4>

<p>方法一是编程并比较N扩大一倍后实际运行时间与分析是否匹配。很多时候很困难。</p>

<p>方法二：验证是否O(f(N))，对N的某个范围计算T(N)/f(n)，T(N)是观察到的运行时间。（收敛于正常数，收敛于0，发散）【？？？】【什么是“用2的倍数隔开”】</p>
]]></content>
  </entry>
  
</feed>
