<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c++ | Jean's Blog]]></title>
  <link href="http://ziwu1216.github.com/blog/categories/c-/atom.xml" rel="self"/>
  <link href="http://ziwu1216.github.com/"/>
  <updated>2013-03-11T10:56:38+08:00</updated>
  <id>http://ziwu1216.github.com/</id>
  <author>
    <name><![CDATA[Jean]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[数据结构与算法分析 读书笔记 2]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/03/10/data-structures-notes-2/"/>
    <updated>2013-03-10T22:39:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/03/10/data-structures-notes-2</id>
    <content type="html"><![CDATA[<p>半个多月前就记了，一直都没整理……</p>

<!--more-->


<h2>第二章 算法分析</h2>

<p>算法是为求解一个问题需要遵循的、被清楚地指定的简单指令的集合。</p>

<h3>2.1 数学基础</h3>

<p><img src="/images/data-structures-notes-2-def.PNG" title="定义" alt="图片加载失败 :(">
这些定义是相对增长率的比较。</p>

<ul>
<li>大O，f是T的上界</li>
<li>omega，g是T的下界</li>
<li>theta，表示严格的增长率相等。<br/>
【？？？】【为什么定义四是对所有常数？】</li>
</ul>


<p>重要法则：<img src="/images/data-structures-notes-2-rule.PNG" title="法则" alt="图片加载失败 :("><br/>
典型增长率：<img src="/images/data-structures-notes-2-rate.PNG" title="典型增长率" alt="图片加载失败 :("></p>

<p>不要将常数或低阶项放进大O</p>

<p>可以通过计算lim（N→+∞）f(N)/g(N)来比较函数的相对增长率（洛必达法则，分子分母求导）</p>

<h3>2.3 要分析的问题</h3>

<p>分析程序的运行时间，一般需要最坏情况而非平均情况，一是因为对所有输入提供界限，二是因为平均计算起来困难。</p>

<p>高效算法中，数据读入常常成为瓶颈。</p>

<h3>2.4 运行时间计算</h3>

<p>一般法则</p>

<ul>
<li>法则1： for循环，时间至多是该循环内语句（包括测试）的运行时间乘以迭代的次数</li>
<li>法则2： 嵌套循环，从里向外分析【也是分析运行时间的基本策略】，一组嵌套循环内部的一条语句总的运行时间，为该语句时间乘以该组所有循环的大小的乘积</li>
<li>法则3： 顺序语句，将各个语句的运行时间求和</li>
<li>法则4： if/else语句，不超过判断语句时间加分支中运行较长的时间之和</li>
</ul>


<p>递归和调用的运行时间分析举例【！！！需复习】<br/>
令T(N)为求解大小为N的问题所花费时间，基准条件得到T(0)，T(1)等，迭代得到关系式如T(N) = 2T(N/2) + O(N),求解。【？？？】【如何求解】</p>

<h4>最大子序列和问题的求解</h4>

<p>多重求和公式计算算法复杂度【！！！需复习】</p>

<p>递归算法，“分治”策略，把整组数据分为左右两个子序列，考虑可能出现在左边，右边，或横跨左右。【！！！需编码】  <br/>
递归函数调用的一般形式是传递输入数组以及左边界和右边界，它们界定了数组要被处理的部分。<br/>
【在递归中，设计传递参数很重要，书中的例子避免了子序列的拷贝，比我开始设计的参数好很多】</p>

<p>联机算法：在任意时刻，算法都能对它已经读入的数据给出问题的正确答案。仅需要常量空间并以线性时间运行的算法几乎是完美的算法。</p>

<h4>O(logN)</h4>

<p>如果一个算法用常数时间将问题的大小削减为其一部分（通常是1/2），那么该算法就是O(logN)的。</p>

<ul>
<li>二分搜索</li>
<li>欧几里得算法</li>
<li>幂运算</li>
</ul>


<h4>检验分析</h4>

<p>方法一是编程并比较N扩大一倍后实际运行时间与分析是否匹配。很多时候很困难。</p>

<p>方法二：验证是否O(f(N))，对N的某个范围计算T(N)/f(n)，T(N)是观察到的运行时间。（收敛于正常数，收敛于0，发散）【？？？】【什么是“用2的倍数隔开”】</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构与算法分析 读书笔记 1]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/02/09/data-structures-notes-1/"/>
    <updated>2013-02-09T13:16:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/02/09/data-structures-notes-1</id>
    <content type="html"><![CDATA[<p>看扫描pdf真心累啊，可是家里没有纸质书。。。</p>

<p>书籍信息：数据结构与算法分析 C++描述（第3版）Mark Allen Weiss 著；张怀勇等译；人民邮电出版社</p>

<!--more-->


<h2>第一章 引论</h2>

<h3>1.1 本书讨论的内容</h3>

<p>问题1：选择问题。设有一组N个数，要确定其中第k个最大的数</p>

<p>问题2：输入由一个二维字母数组和一个单词表组成，找出水平、垂直或对角方向放置的单词</p>

<h3>1.2 数学知识复习</h3>

<ul>
<li>几何级数：<img src="/images/data-structures-notes-1-jihe.PNG" title="几何级数" alt="图片加载失败 :("></li>
<li>算术级数：<img src="/images/data-structures-notes-1-suanshu.PNG" title="算术级数" alt="图片加载失败 :("></li>
<li><img src="/images/data-structures-notes-1-gaojie.PNG" title="高阶" alt="图片加载失败 :("></li>
<li>调和数：<img src="/images/data-structures-notes-1-tiaohe.PNG" title="调和数" alt="图片加载失败 :("></li>
</ul>


<p>归纳法：第一步证明基准情形（对于某个或某些值），接着归纳假设（k），然后证明k+1。必须k有限。</p>

<h3>1.3 递归的简单介绍</h3>

<p>递归：需要处理基准情况base case和递归调用。</p>

<p>递归的基本准则</p>

<ul>
<li>基准情形</li>
<li>不断推进：递归调用将一直进行到基准情形出现为止，若永远不能到达基准情形，则出错。</li>
<li>设计法则：假设所有的递归调用都能运行。不追踪实际的递归调用序列。</li>
<li>合成效益法则：在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。</li>
</ul>


<h3>1.4 C++类</h3>

<p>构造函数中，const数据成员和自定义类数据成员，必须在初始化列表里初始化</p>

<p>所有单参数的构造函数都必须是explicit的，以避免后台的类型转换</p>

<p>C++标准定义了两个类vector和string，意在替代内置数组和字符串，增加了=复制、大小确定、==比较等，使用他们几乎总是较好的选择</p>

<h3>1.5 C++细节</h3>

<p>指针最好进行初始化，可以初始化为NULL</p>

<p>按值调用适用于不被函数更改的小对象，按常量引用调用适用于不被函数更改的大对象，引址调用适用于所有可以被函数更改的对象</p>

<p>如果返回值是类类型的，可以使用按常量引用返回以节省复制的开销，但必须保证返回语句中的表达式在函数返回时不被销毁。</p>

<p>三个默认特殊函数：</p>

<ul>
<li>析构函数</li>
<li>复制构造函数：IntCell B = C； IntCell B(C); 按值调用传递时；按值返回时。<br/>
每个数据成员依次复制，若有类对象的数据成员，调用数据成员的复制构造函数</li>
<li>operator=</li>
</ul>


<p>有指针数据成员时，默认特殊函数会造成内存泄露和浅复制</p>

<h3>1.6 模板</h3>

<p>函数模板可以应需要而自动扩展-->代码膨胀</p>

<p>模板实参可以使用任何类类型，因此尽量使用常量引用</p>

<p>类模板：例如数据成员类型不确定</p>

<p>函数对象：定义一个包含零个数据和一个成员函数的类。使用operator(),调用cmp.operator()(x,y)可以简写为cmp(x,y)，看上去就像函数调用，因此operator()被称为函数调用操作符</p>

<p>``` c++
class CaseInsensitiveCompare
{
public:</p>

<pre><code>bool operator()(const string &amp; lhs, const string &amp; rhs) const
{ return stricmp(lhs.c_str(), rhs.c_str()) &lt; 0; } 
</code></pre>

<p>};</p>

<p>template <typename Object, typename Comparator>
const Object &amp; findMax(const vector<Object> &amp; arr, Comparator isLessThan)
{</p>

<pre><code>...
isLessThan(arr[maxIndex], arr[i])
...
</code></pre>

<p>}</p>

<p>int main()
{</p>

<pre><code>...
cout &lt;&lt; findMax(arr, CaseInsensitiveCompare()) &lt;&lt; endl;
...
</code></pre>

<p>}
```</p>

<h3>1.7 使用矩阵</h3>

<p>矩阵matrix类的构造：使用向量的向量，重载operator[]。需要有两个版本的operator[],因为<code>to[i] = from[i]</code>,需要返回一个常量引用给from，返回一个普通引用给to。</p>

<p>【？？？】【C++这样重载可以正常工作吗？为什么知道调用哪个operator[]？】</p>

<p>``` c++
public:</p>

<pre><code>const vector&lt;Object&gt; &amp; operator[](int row) const
{ return array[row]; }
vector&lt;Object&gt; &amp; operator[](int row)
{ return array[row]; }
</code></pre>

<p>private:</p>

<pre><code>vector&lt; vector&lt;Object&gt; &gt; array;
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Primer 读书笔记 1]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/01/05/c-plus-plus-primer-notes-1/"/>
    <updated>2013-01-05T15:50:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/01/05/c-plus-plus-primer-notes-1</id>
    <content type="html"><![CDATA[<p>最近在看一些源代码，立刻发现自己的C++功底相当的弱，于是决定静心开始读经典的《C++ Primer》中文版，开头似乎是入门的知识，所以决定做些笔记，偶尔加些自己的验证。这样以后直接翻笔记就行了。笔记很零碎，感觉很适合C++考试的选择题……汗。</p>

<p>书籍信息：C++ Primer 中文版（第4版）Stanley B. Lippman, Josee Lajoie, Barbara E. Moo 著；李师贤等译；人民邮电出版社</p>

<p>以下为第一章笔记。</p>

<!--more-->


<h2>第一章</h2>

<h3>1.1</h3>

<ul>
<li><p>返回值必须和函数的返回类型相同，或者可以转换成函数的返回类型<br/>
【需要返回double时可以return int，反之不行】</p></li>
<li><p>常见C++程序文件后缀： *.cc *.cxx *.cpp *.cp *.C</p></li>
</ul>


<h3>1.2</h3>

<ul>
<li><p>iostream库的基础是两种命名为istream和ostream的类型，分别表示输入流和输出流。标准库定义了4个IO对象，处理输入时使用命名为cin的istream类型对象，也称为标准输入。处理输出时使用命名为cout的ostream类型对象，也称为标准输出。另外，cerr和clog都是ostream对象。<br/>
【都忘了原来istream是类啊】</p></li>
<li><p>输出操作符&lt;&lt;：接受两个操作数，左操作数必须是ostream对象，右操作数是要输出的值，返回输出流本身（即左操作数）。输入操作符类推。</p></li>
<li><p>endl称为操纵符（manipulator），换行，刷新与设备相关联的缓冲区，用户立即看到写入到流中的输出。忘记刷新输出流可能会造成输出停留在缓冲区中，如果程序崩溃，将会导致对程序崩溃位置的错误推断。</p></li>
<li><p>使用命名空间，可以避免由于无意中使用了与库中所定义名字相同的名字而引起冲突。从而我们可以使用与标准库相同的名字。</p></li>
<li><p>空格符不允许出现在预处理指示中<br/>
【<br/>
预处理是指在编译前所作的工作。例如#include, #define等<br/>
带参宏定义中，宏名和形参表之间不能有空格出现<br/>
例如<code>#define MAX(a,b) (a&gt;b)?a:b</code>不能写成<code>#define MAX (a,b) (a&gt;b)?a:b</code><br/>
】</p></li>
</ul>


<h3>1.3</h3>

<ul>
<li>注释对不可嵌套。临时忽略一段代码更好的方法，是用编辑器在要忽略的每一行代码前面插入单行注释//，这样就无需担心是否已包含注释对/**/</li>
</ul>


<h3>1.4</h3>

<ul>
<li><p>for(int val = 1; val &lt;= 10; ++ val)执行顺序：</p>

<ol>
<li>创建val并初始化为1</li>
<li>测试val是否&lt;= 10<br/>
【<br/>
第一次进入时就要测试！！<br/>
<code>for(int val = 11; val &lt;= 10; ++ val) cout&lt;&lt;val&lt;&lt;endl;</code><br/>
不会有输出<br/>
】</li>
<li>如果是，则执行for循环体；如果不是，则退出循环</li>
<li>Val递增</li>
<li>重复第2步的测试</li>
</ol>
</li>
<li><p>读入未知数目的输入<br/>
<code>while(cin &gt;&gt; value) sum += value;</code><br/>
测试cin，即测试流的状态。如果流有效，测试成功。遇到文件结束符或无效输入【如类型和value不符合】，条件失败。<br/>
【</p></li>
</ul>


<p>```c
int main()
{</p>

<pre><code>int value;
while(cin &gt;&gt; value) 
    cout&lt;&lt;value&lt;&lt;endl;
return 0;
</code></pre>

<p>}
```</p>

<p>在输入<code>1 2 3 回车</code>后会显示</p>

<p><code>
1 2 3
1
2
3
</code></p>

<p>可以继续输入。<br/>
在输入<code>1 2 3 ^Z 回车</code>或<code>1 2 3 str 回车</code>后会显示</p>

<p><code>
1 2 3 str
1
2
3
请按任意键继续. . .
</code></p>

<p>不可以继续输入。<br/>
回车的作用：windows是行缓冲，只有按下回车后，系统才会将输入的这一行数据存放到程序的输入缓存中。<br/>
】</p>

<ul>
<li>文件结束符，windows下ctrl+z，unix下ctrl+d</li>
</ul>


<h3>1.5</h3>

<ul>
<li>标准库的头文件用&lt;>， 非标准库的文件用””</li>
</ul>

]]></content>
  </entry>
  
</feed>
