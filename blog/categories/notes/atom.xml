<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: notes | Jean's Blog]]></title>
  <link href="http://ziwu1216.github.com/blog/categories/notes/atom.xml" rel="self"/>
  <link href="http://ziwu1216.github.com/"/>
  <updated>2013-05-24T00:29:01+08:00</updated>
  <id>http://ziwu1216.github.com/</id>
  <author>
    <name><![CDATA[Jean]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++ Primer 读书笔记 2]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/05/24/c-plus-plus-primer-notes-2/"/>
    <updated>2013-05-24T00:01:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/05/24/c-plus-plus-primer-notes-2</id>
    <content type="html"><![CDATA[<p>有些细节的地方综合网络作了补充</p>

<!--more-->


<h2>第二章</h2>

<h3>2.1</h3>

<p>8bits - byte，4bytes - word</p>

<p>基本内置类型</p>

<table class="table table-bordered table-striped table-condensed">
    <tr>
        <td>char:</td>
        <td>1byte</td>
        <td>基本字符集<br>char/unsigned char/signed char<br>(使用unsigned或signed来表示char，由编译器决定)</td>
    </tr>
    <tr>
        <td>wchar_t：</td>
        <td>2 or 4bytes</td>
        <td>扩展字符集（汉字和日文）</td>
    </tr>
    <tr>
        <td>bool：</td>
        <td>1byte</td>
    </tr>
    <tr>
        <td></td>
    </tr>
    <tr>
        <td>short int (short)：</td>
        <td>2bytes</td>
        <td>半个word，short/unsigned short</td>
    </tr>
    <tr>
        <td>int:</td>
        <td>4bytes</td>
        <td>一个word，int/unsigned</td>
    </tr>
    <tr>
        <td>long int (long)：</td>
        <td>4bytes</td>
        <td>long/unsigned long</td>
    </tr>
    <tr>
        <td>long long int: </td>
        <td>8bytes</td>
    </tr>
    <tr>
        <td></td>
    </tr>
    <tr>
        <td>float：</td>
        <td>4bytes</td>
        <td> ~7 digits</td>
    </tr>
    <tr>
        <td>double：</td>
        <td>8bytes </td>
        <td>~15 digits</td>
    </tr>
    <tr>
        <td>long double：</td>
        <td>8bytes</td>
        <td>~15 digits</td>
    </tr>
</table>


<ul>
<li>无符号，最高位和其它位一样，用来表示该数的大小。</li>
<li>有符号，最高位为符号位，1表示负值。</li>
</ul>


<p>正数按原码存放，负数按补码存放。补码就是符号位不变，其余位数取反加1（从最低位开始至找到的第一个1均不变，符号位不变）。-1，原码是10000001，补码应该是11111111</p>

<p>很多时候，把超过取值范围的值赋给unsigned和signed类型，编译器会取模后存储。</p>

<h3>2.2</h3>

<p>字面值常量literal constant。只有内置类型存在字面值。
<code>c
20;//十进制
024;//八进制以0开头
0x14;//十六进制以0X或0x开头
128u;//unsigned
1024UL or 1024Lu;//unsigned long
1L;//long
3.14159f;
.001f;
0.;
1E-3F;
L'a';//wchar_t
\0;//转义字符\可以将ASCII码转为字面值常量
L"a wide string literal";
</code></p>

<h3>2.3</h3>

<p>变量初始化：</p>

<p><code>c
int ival(1024);//直接初始化
int ival = 1024;//复制初始化
double salary = 9.9, wage(salary + 0.01);//用前一个变量初始化后一个变量
</code></p>

<p>定义未初始化的变量时：</p>

<ul>
<li>内置类型：函数体外定义的自动初始化为0，函数体内定义的不自动初始化</li>
<li>类类型：必须有默认构造函数才能自动初始化，否则无法定义没有初始值的变量</li>
</ul>


<p>变量的定义用于为变量分配存储空间，可以指定初始值。变量有且仅有一个定义。<br/>
变量的声明用于向程序表明变量的类型和名字，可以声明多次。定义也是声明。</p>

<p>```c
extern int i;//声明不定义，在file2，可以使用file1里的变量i(外部存储类型)
int i;//定义，在file1</p>

<p>extern double pi = 3.1416;//定义，因为有初始化，要分配空间
```</p>

<p>变量的作用域</p>

<ul>
<li>全局作用域：所有函数外部，在程序的任何地方访问</li>
<li>局部作用域：<code>{}</code>括起来的代码范围，例如函数内部</li>
<li>语句作用域：for等语句内，从它定义的位置开始，一直到for所带语句的作用域结束</li>
<li>类作用域：每个类的成员不同于任何其他类(任何其他作用域)的成员</li>
<li>命名空间作用域：namespace</li>
</ul>


<h3>2.4</h3>

<p>```c
const int bufSize = 512;//常量在定义时必须初始化</p>

<p>extern const int bufSize = fcn();//定义，在file1
//在全局作用域声明的const变量是定义该对象的文件的局部变量，不能被其他文件访问
//需要加extern，才能被其他文件访问
extern const int bufSize;//声明，在file2，可以使用file1里的变量
```</p>

<h3>2.5</h3>

<p>```c
int ival = 1024;
int &amp;refval = ival;//引用只是别名，引用不可能在初始化后绑定到其他对象
int &refVal2;//错误，引用必须初始化
int &amp;refVal3 = 10;//错误，引用必需使用同类型的对象初始化</p>

<p>const int i = 1024;
const int &amp;ref = i;//指向const对象的引用
const int &amp;r = 42;//正确，const引用可以绑定到右值</p>

<p>double dval = 3.14;
const int &amp;ri = dval;//正确，const引用可以绑定到不同但相关的类型
//编译器会做如下转换，如果允许非const引用，则对ri的修改只能修改temp，不能修改dval
//int temp = dval;
//const int &amp;ri = temp;
```</p>

<h3>2.6</h3>

<p>typedef可以用来定义类型的同义词
<code>c
typedef int exam_socre;
</code></p>

<h3>2.7</h3>

<p>枚举变量，默认第一个枚举成员赋值为0，后面比前面一个加1
<code>c
enum Points{point2d = 2, point2w, point3d = 3, point3w};
//point2d = 2, point2w = 3比前一个大1
//point3d = 3, 和point2w值重复了，是可以的
//point3w = 4
</code></p>

<h3>2.8</h3>

<p><code>class</code>在第一个访问标号前的任何成员都隐式指定为<code>private</code>，<code>struct</code>则指定为<code>public</code></p>

<h3>2.9</h3>

<p>编译和链接多个源文件
<code>
CC -c main.cc Sales_item.cc
</code>
或者
<code>
CC -c main.cc
CC -c Sales_item.cc
CC main.o Sales_item.o
</code></p>

<p>头文件中只能有声明，不能有定义。例外：</p>

<ul>
<li>定义类</li>
<li>定义值在编译时就已知的const对象<br/>
上文“const变量是定义该对象的文件的局部变量”就是为了允许这么做<br/>
实践中，大部分编译器会用相应的常量表达式来替换对这些const变量的使用，所以不会有存储空间存储这类const变量<br/>
不是编译时已知值的const对象不应该放在头文件</li>
<li>定义inline函数</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编程之美 读书笔记 1]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/05/16/beauty-of-programming-1/"/>
    <updated>2013-05-16T23:29:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/05/16/beauty-of-programming-1</id>
    <content type="html"><![CDATA[<p>书籍信息：编程之美——微软技术面试心得；《编程之美》小组著；电子工业出版社</p>

<p>从第二章开始看起的，毕竟是件很功利的事情。</p>

<!--more-->


<h3>2.1</h3>

<p>用右移达到除2的效果，效率很高，可以多想想是否可以利用</p>

<p>求1的个数：var = var &amp; (var - 1)</p>

<p>用查表法，以空间换时间</p>

<p>我写的代码
```c
int findOne(unsigned var) {</p>

<pre><code>int cnt = 0;
while(var != 0) {
    var = var &amp; (var - 1);
    cnt++;
}
return cnt;
</code></pre>

<p>}
<code>
代码修改-注意注释
</code>c</p>

<h1>include <iostream></h1>

<p>using namespace std;</p>

<p>typedef unsigned char BYTE;//常用的宏定义，unsigned int范围不进行检查的话不符合题意</p>

<p>int findOne(BYTE var) {</p>

<pre><code>int cnt = 0;
while(var) {//var!=0冗余
    var &amp;= (var - 1);//复合赋值更高效简洁
    cnt++;
}
return cnt;
</code></pre>

<p>}
int main() {</p>

<pre><code>unsigned a;//直接输入给BYTE会得到ASCII码值
BYTE b;
int c;
while(cin&gt;&gt;a) {
    if(a&gt;0xff) {
//0x前缀表示16进制数，x不区分大小写。0前缀表示8进制数。没有提供直接写2进制数的方法.
//8进制和16进制只能表达无符号的正整数
        cout&lt;&lt;"error"&lt;&lt;endl;
        continue;
    }
    b = (BYTE)a;//【？？？】是否有更恰当的方法，将输入以数字的值读入BYTE？
    c = findOne(a);
    cout&lt;&lt;c&lt;&lt;endl;
}
return 0;
</code></pre>

<p>}
```</p>

<h3>2.2</h3>

<p>在比较运算符两边（如&lt;），有符号数和无符号数要匹配</p>

<p>不小于N的数中出现能被5整除的个数：Z=[N/5]+[N/25]+[N/125]+...每5个一数，有一个数中含有因子5。而每25个一数，有一个数中含有因子25，即2个5，因为之前每5个一数时已经算过一次，所以再加一次</p>

<p>二进制最低位1的位置决定于含有因子2的个数</p>

<p>【？？？】问题2的解法二想不到</p>

<h3>2.3</h3>

<p>把问题转化为同等性质的更小规模的问题。如果某元素个数超过整个数组的一半，那么删除一对不同的元素后，此元素依然超过一半。</p>

<p>【？？？】如何传递数组和指针作为实参，引用传递，const传递等</p>

<h3>2.4</h3>

<p>找规律的题目，我所不擅长的。这里是分别考虑个位、十位、百位...</p>

<p>我写的代码
```c
unsigned long long calc(unsigned long long num) {</p>

<pre><code>unsigned long long less;
unsigned long long sum = 0;
unsigned long long factor = 1;
unsigned long long temp = num;
while(temp != 0) {
    less = temp - temp / 10 * 10;
    temp = temp/10;
    if(less == 0)
        sum += num * factor;
    else if(less == 1)
        sum += temp * factor + num - (num / factor * factor) + 1;
    else
        sum += (temp + 1) * factor;
    factor *= 10;
}
return sum;
</code></pre>

<p>}
<code>
代码修改
</code>c
unsigned long long calc(unsigned long long num) {</p>

<pre><code>unsigned long long sum = 0;
unsigned long long factor = 1;
unsigned long long lowerNum = 0;
unsigned long long currNum = 0;
unsigned long long higherNum = 0;
//改用这些变量后程序可读性增强了很多
//写程序时还是要抓住解决方案的本质，用简明的方法表达出来
//如果写的时候觉得很难表达清楚，一定是还没有理清思路，不要急着开始写程序

while(num / factor != 0) {
    lowerNum = num - num / factor * factor;
    currNum = (num / factor) % 10;
    higherNum = num / factor / 10;

    if(currNum == 0)
        sum += higherNum * factor;
    else if(currNum == 1)
        sum += higherNum * factor + lowerNum + 1;
    else
        sum += (higherNum + 1) * factor;
    factor *= 10;
}
return sum;
</code></pre>

<p>}
```
【？？？问题2实在是太绕了，没看明白】</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构与算法分析 读书笔记 4]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/03/18/data-structures-notes-4/"/>
    <updated>2013-03-18T23:53:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/03/18/data-structures-notes-4</id>
    <content type="html"><![CDATA[<p>第三章剩下的部分</p>

<!--more-->


<h2>第三章 表、栈和队列</h2>

<h3>3.4 向量的实现</h3>

<p>vector是基本类类型，这意味着不同于基本数组，vector可以复制并且其占用的内存可以自动回收（通过析构函数）</p>

<p>【？？？】程序第37行，为什么<code>reserve()</code>函数中判断的是<code>newCapacity &lt; theSize</code>而不是<code>newCapacity &lt; theCapacity</code>？</p>

<h3>3.5 表的实现</h3>

<p>在表的前端和末尾添加额外结点作为标志，称为哨兵结点。头部结点称为表头结点，末端的结点称为尾结点。使用好处是可以去掉很多特例，简化程序代码。</p>

<p>List中的代码摘抄<br/>
``` c
class List
{
private:</p>

<pre><code>struct Node{...};
</code></pre>

<p>public:</p>

<pre><code>class const_iterator{...};
class iterator: public const_iterator{...};
...
</code></pre>

<p>private:</p>

<pre><code>int theSize;
Node *head;
Node *tail;
...
</code></pre>

<p>};
```</p>

<p>定义前缀和后缀<code>operator++</code>的区别方法：给前缀指定空参数表，给后缀指定一个匿名的int参数。实现指出在许多可以选择使用前缀或后缀的情况下，使用前缀形式要快于使用后缀形式<br/>
``` c
const_iterator operator++()
{</p>

<pre><code>current = current-&gt;next;
return *this;
</code></pre>

<p>}</p>

<p>const_iterator operator++(int)
{</p>

<pre><code>const_iterator old = *this;
++(*this);
return old;
</code></pre>

<p>}
```</p>

<h3>3.6 栈ADT</h3>

<p>栈的操作基本只有<code>push(),pop(),top()</code>，只有栈顶元素是可访问的。</p>

<p>栈是一个表，用数组和单向链表都可以实现，所以list和vector都支持栈，且操作为常量时间操作。</p>

<h4>栈的应用</h4>

<p>后缀或逆波兰记法：将<code>4.99*1.06 + 5.99 +6.99*1.06</code>（称为中缀式）记为<code>4.99 1.06 * 5.99 + 6.99 1.06 * +</code>。   当一个表达式以后缀记法给出时，没有必要知道任何优先规则。</p>

<p>可以用栈实现中缀式到后缀式的转换，主要原则是入栈操作符，读取新操作符时，从栈顶弹出直到遇到优先级更低的元素为止【需复习】</p>

<p>尾递归：在最后一行的递归调用，是极差的使用递归的例子。<br/>
通过将代码放到一个while循环中并用每个函数的一个参数代替递归调用，可以机械地消除尾递归。【？？？】不明白尾递归和其他递归的本质区别<br/>
递归总能够被彻底除去（编译器的工作），但提速的同时降低了程序的清晰性。</p>

<h3>3.7 队列ADT</h3>

<p>队列也是表。基本操作<code>enqueue(),dequeue()</code></p>

<p>循环数组：处理front或back到达数组尾端，而数组前面有很多空位的情况。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构与算法分析 读书笔记 3]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/03/14/data-structures-notes-3/"/>
    <updated>2013-03-14T23:58:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/03/14/data-structures-notes-3</id>
    <content type="html"><![CDATA[<p>3.1到3.3节。重点记录的是vector和list的操作函数，因为以前用的比较少</p>

<!--more-->


<h2>第三章 表、栈和队列</h2>

<h3>3.1 抽象数据类型ADT</h3>

<p>抽象数据类型（ADT）是带有一组操作的一些对象的集合。在ADT的定义中根本没有提到这组操作是如何实现的</p>

<h3>3.2 表ADT</h3>

<ul>
<li>简单数组实现：适合在末尾插入元素，之后只有数组访问<br/>
数组是静态分配的，但vector类允许在需要的时候将数组的大小增加一倍</li>
<li>链表实现：适合插入和删除在整个表中都发生<br/>
典型的链表保持至表的两端的链接，为了第一项的添加删除和末尾的新项添加为常量时间【应该是由于在两端操作数据最为常见】<br/>
双向链表，可以方便删除最后一项(方便找到倒数第二项)</li>
</ul>


<h3>3.3 STL中的向量和表</h3>

<p>标准模板库STL实现了公共数据结构，例如表ADT。这些数据结构称为集合（collection）或容器（container）</p>

<ul>
<li>vector给出了表ADT的可增长的数组实现。<br/>
优点：常量时间内可索引【findKth】，缺点：插入或删除代价昂贵（除非发生在末尾），查找效率低【find】</li>
<li>list提供表ADT的双向链表实现。<br/>
优点：插入和删除代价小，缺点：不容易索引，查找效率低</li>
</ul>


<p>常用方法：<br/>
``` c
int size() const;
void clear();//删除容器内的所有元素
bool empty();
//以下四个都为常量时间
void push_back(const Object &amp; x);//在表的末尾添加x
void pop_back();//删除表的末尾对象
const Object &amp; back() const;
const Object &amp; front() const;</p>

<p>//仅针对list
void push_front(const Object &amp; x);
void pop_front();</p>

<p>//仅针对vector
Object &amp; operator<a href="int%20idx"></a>;//不包含边界检测
Object &amp; at(int idx);//包含边界检测
int capacity() const;//返回vector的内部容量
void reserve(int new Capacity);//设定vector的新容量
```</p>

<h4>迭代器iterator</h4>

<p>通过内置类型iterator来标记位置，例如<code>list&lt;string&gt;::iterator</code>和<code>vector&lt;int&gt;::iterator</code></p>

<p>相关方法：<br/>
<code>c
iterator begin();//返回指向容器第一项的适当迭代器
iterator end();//指向容器的终止标志，容器中最后一项的后面的位置，边界之外
itr++; ++itr;
*itr;//返回itr指定位置的对象的引用
itr1 == itr2; itr1 != itr2;//是否指向同一个位置
iterator insert(iterator pos, const Object &amp; x);//返回插入项位置。对list常量时间，对vector不是
iterator erase(iterator pos);//返回pos下一个元素的位置，操作完成后pos失效
iterator erase(iterator start, iterator end);//删除的元素直到但不包括end
</code>
【注意错误】我写的对表使用erase的代码
``` c WRONG!!!
//1.erase后itr失效，不能继续使用了
//2.使用itr+2操作会超过lst.end()，越界
//...是否还有其他错误？</p>

<p>template <typename Container>
void removeEveryOtherItem(Container &amp; lst)
{</p>

<pre><code>for(Container::iterator itr = lst.begin(); itr != lst.end(); itr=itr+2)
    lst.erase(itr);
</code></pre>

<p>}
```</p>

<p>STL也包含const_iterator，*const_iterator会返回常量引用，不能成为左值</p>

<p><code>c
iterator begin()
const_iterator begin() const
</code></p>

<p>两个版本的begin可以在同一个类里，因为方法的定常性被认为是标号的一部分
如果对非常量容器调用begin，返回iterator的版本被调用。如果对常量容器调用，返回const_iterator</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数据结构与算法分析 读书笔记 2]]></title>
    <link href="http://ziwu1216.github.com/blog/2013/03/10/data-structures-notes-2/"/>
    <updated>2013-03-10T22:39:00+08:00</updated>
    <id>http://ziwu1216.github.com/blog/2013/03/10/data-structures-notes-2</id>
    <content type="html"><![CDATA[<p>半个多月前就记了，一直都没整理……第二章</p>

<!--more-->


<h2>第二章 算法分析</h2>

<p>算法是为求解一个问题需要遵循的、被清楚地指定的简单指令的集合。</p>

<h3>2.1 数学基础</h3>

<p><img src="/images/data-structures-notes-2-def.PNG" title="定义" alt="图片加载失败 :(">
这些定义是相对增长率的比较。</p>

<ul>
<li>大O，f是T的上界</li>
<li>omega，g是T的下界</li>
<li>theta，表示严格的增长率相等。<br/>
【？？？】【为什么定义四是对所有常数？】</li>
</ul>


<p>重要法则：<img src="/images/data-structures-notes-2-rule.PNG" title="法则" alt="图片加载失败 :("><br/>
典型增长率：<img src="/images/data-structures-notes-2-rate.PNG" title="典型增长率" alt="图片加载失败 :("></p>

<p>不要将常数或低阶项放进大O</p>

<p>可以通过计算lim（N→+∞）f(N)/g(N)来比较函数的相对增长率（洛必达法则，分子分母求导）</p>

<h3>2.3 要分析的问题</h3>

<p>分析程序的运行时间，一般需要最坏情况而非平均情况，一是因为对所有输入提供界限，二是因为平均计算起来困难。</p>

<p>高效算法中，数据读入常常成为瓶颈。</p>

<h3>2.4 运行时间计算</h3>

<p>一般法则</p>

<ul>
<li>法则1： for循环，时间至多是该循环内语句（包括测试）的运行时间乘以迭代的次数</li>
<li>法则2： 嵌套循环，从里向外分析【也是分析运行时间的基本策略】，一组嵌套循环内部的一条语句总的运行时间，为该语句时间乘以该组所有循环的大小的乘积</li>
<li>法则3： 顺序语句，将各个语句的运行时间求和</li>
<li>法则4： if/else语句，不超过判断语句时间加分支中运行较长的时间之和</li>
</ul>


<p>递归和调用的运行时间分析举例【！！！需复习】<br/>
令T(N)为求解大小为N的问题所花费时间，基准条件得到T(0)，T(1)等，迭代得到关系式如T(N) = 2T(N/2) + O(N),求解。【？？？】【如何求解】</p>

<h4>最大子序列和问题的求解</h4>

<p>多重求和公式计算算法复杂度【！！！需复习】</p>

<p>递归算法，“分治”策略，把整组数据分为左右两个子序列，考虑可能出现在左边，右边，或横跨左右。【！！！需编码】  <br/>
递归函数调用的一般形式是传递输入数组以及左边界和右边界，它们界定了数组要被处理的部分。<br/>
【在递归中，设计传递参数很重要，书中的例子避免了子序列的拷贝，比我开始设计的参数好很多】</p>

<p>联机算法：在任意时刻，算法都能对它已经读入的数据给出问题的正确答案。仅需要常量空间并以线性时间运行的算法几乎是完美的算法。</p>

<h4>O(logN)</h4>

<p>如果一个算法用常数时间将问题的大小削减为其一部分（通常是1/2），那么该算法就是O(logN)的。</p>

<ul>
<li>二分搜索</li>
<li>欧几里得算法</li>
<li>幂运算</li>
</ul>


<h4>检验分析</h4>

<p>方法一是编程并比较N扩大一倍后实际运行时间与分析是否匹配。很多时候很困难。</p>

<p>方法二：验证是否O(f(N))，对N的某个范围计算T(N)/f(n)，T(N)是观察到的运行时间。（收敛于正常数，收敛于0，发散）【？？？】【什么是“用2的倍数隔开”】</p>
]]></content>
  </entry>
  
</feed>
